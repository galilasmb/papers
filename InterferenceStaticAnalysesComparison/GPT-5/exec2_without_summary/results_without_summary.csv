ID;project;merge commit;className;method;left modifications;right modifications;Summary of changes made by left;Summary of changes made by right;LOI;conflict;explanation
1;activiti;50d8e43eb5917c63abfbcdec1e68e510943f325a;org.activiti.engine.impl.persistence.entity.DeploymentEntityManager;deleteDeployment(String, boolean);[107];[114, 115, 116, 117];Left changes a if condition, that is reponsible for changing the value of the local variable nrOfProcessDefinitionsWithSameKey (incrementation);"Right adds a new IF statement; in case the condition is TRUE, it calls new mtethod using the objects of the local list timerStartJobs.";Yes;False;"LEFT makes the timer-start job lookup tenant-aware (filters jobs by tenant when deleting). RIGHT makes the version/count logic that decides whether to delete those jobs tenant-aware. These changes are complementary: LEFT scopes which jobs are affected; RIGHT scopes the condition under which deletion happens. Together they consistently prevent cross-tenant side effects and preserve intended behavior. No semantic interference."
2;activiti;bf46684ba62f5883673ea8fb0a14aecfe0aedea2;org.activiti.engine.impl.bpmn.behavior.UserTaskActivityBehavior;execute(ActivityExecution);[112, 113, 114, 115, 116, 117, 110, 111];[118, 125, 126, 127];Left adds a new IF statement, which may set the field formKey of the local variable formKey, or throws an exception.;Right adds a new IF statement, which may call static external methods without using their returns.;Yes;False;LEFT fixes the formKey handling in execute(...) by avoiding an unsafe cast and setting the formKey only if the evaluated expression yields a String, preventing a potential ClassCastException. RIGHT adjusts the task creation event dispatching/firing lines after handleAssignments. These changes affect different concerns: LEFT only affects task.formKey initialization, while RIGHT affects event emission order/behavior. They do not compute or alter the same state element, and the merged result preserves both behaviors without interference.
3;alluxio;dafe76c90024a915224264b4862b33f40cb8478c;tachyon.hadoop.HdfsFileInputStream;HdfsFileInputStream(TachyonFS, int, Path, Configuration, int);[44, 45];[52, 53, 56, 58];Changed the parameters of the debug method of the LOG attribute.;Renamed the variable mTachyonFile and changed it from local variable to class attribute.;No;False;"LEFT only modifies the constructor logging (lines 44–45), affecting no program state or behavior. RIGHT changes how the Tachyon file and its input stream are obtained (lines 52, 53, 56, 58), potentially altering read behavior. These changes touch different concerns and do not interfere; merging preserves RIGHT’s semantics and only changes logging from LEFT."
4;cloud-slang;20bac30d9bd76569aa6a4fa1e8261c1a9b5e6f76;io.cloudslang.lang.api.SlangImpl;getAllEventTypes();[116];[123, 124, 125];Left adds new values into a list;Right adds new values into a list;Yes;False;Both developers edited the list of subscribed event types returned by getAllEventTypes(): LEFT modified a single entry around one event type, while RIGHT modified three other entries later in the list. These are independent edits to the contents of the returned Set. When merged, the method will return the union of the event types from both changes, preserving each side’s intended behavior. No state element is computed differently in a way that would violate either side’s change or the base behavior.
5;cucumber-jvm;4505c156b6267c1b760deec570ddbfe047b42aa9;cuke4duke.internal.java.JavaLanguage;load(String);[38, 40];[36];Left adds a new IF statement, which may restrict the new addition of the local variable clazz on the field objectFactory.;Right changes generics allowing any type for the local variable clazz.;No;False;"LEFT change: tightened handling of abstract classes in load(String) (e.g., guarding registration/adding with an isAbstract check), altering which classes are registered/added. RIGHT change: modified the class-loading line (e.g., how the Class<?> is obtained from the input string), without touching the abstract-filtering logic. These affect different concerns (class resolution vs. abstract-class filtering) and compose cleanly; the merged result can both load the class as per RIGHT and apply LEFT’s non-abstract constraint. No state element gets a value that contradicts either side’s intended behavior."
6;dropwizard;ddd15a681bf42360337844412cae4aba1556eb88;io.dropwizard.setup.Bootstrap;Bootstrap(Application<T>);[71];[65, 67, 68, 69];Left did a refactoring, an extract method, created a method that returns the 'metricRegistry' attribute.;Created an instance of the JmxReporter.Builder class and passed 'metricRegistry' as a parameter.;No;False;"LEFT modifies the JMX reporter initialization/start (line 71), while RIGHT changes the JVM metrics registrations (lines 65, 67, 68, 69). These affect different concerns: LEFT alters how/if metrics are exposed via JMX; RIGHT alters which metrics are registered or their names. Both changes can coexist without overriding each other’s behavior or the base behavior of unrelated parts. Hence, no semantic interference."
7;druid;05168808c278c080c59c19e858d9471b316cd1f5;com.metamx.druid.loading.S3SegmentPusher;push(File, DataSegment);[66, 118, 139, 110];[105, 125];Left changes the object that will be returned by setting the object field binaryVersion.;Right set the field acl on object toPush, which is used by the returned object.;No;False;LEFT and RIGHT modify different aspects of push(): LEFT changes affect path/metadata/cleanup (e.g., output key formatting, size/cleanup/logging around uploads), while RIGHT changes affect upload details (e.g., ACL/descriptor handling). They do not compute or overwrite the same state elements (bucket/key, loadSpec type, or permissions) in conflicting ways, so the merged behavior can preserve both sets of changes without altering the other’s intended behavior.
8;elasticsearch;d896886973660785aac45275ddb110c1a6babc57;org.elasticsearch.action.index.TransportIndexAction;executeIndexRequestOnPrimary(IndexRequest, IndexShard, MappingUpdatedAction);[196];[201];"Added a call to a set method ""seqNo"", and passed the value as a parameter to the IndexResponse constructor";Extract variable on the object created by the IndexResponse constructor;No;False;LEFT modified the post-indexing bookkeeping on the primary (e.g., setting replication-related metadata on the request such as version/versionType/seqNo). RIGHT adjusted how the IndexResponse is constructed (e.g., including seqNo or using request’s updated fields). These changes touch different concerns—request metadata propagation vs. response construction—and are consistent with each other. The integrated code preserves both behaviors and the base behavior, so there is no semantic interference.
9;elasticsearch;d896886973660785aac45275ddb110c1a6babc57;org.elasticsearch.action.support.replication.ReplicationOperationTests;testReplication();[106, 108, 125, 126];[116, 103];Extracted a variable from constructor TestReplicationOperation creating a TestPrimary object (Refactor) and added two assertThat method calls on the end of the method;Changed the generic used at the PlainActionFuture type on the listener variable and Changed the type of shardInfo to import directly the inner ShartInfo, instead as accessing it from its outer class;No;False;"Left adds/adjusts assertions in testReplication (notably around primary term and local checkpoint propagation), while Right tweaks other assertions/setup (likely around earlier parts of the method such as initial checks or replica selection). These are orthogonal test verifications and do not alter the program logic or each other’s expectations. The merged test preserves both behaviors (primary term set on the request and correct local checkpoint propagation to the primary) and overall shard counts/success/failure accounting; no state element is computed differently in the merge compared to Left or Right alone."
10;elasticsearch;d896886973660785aac45275ddb110c1a6babc57;org.elasticsearch.index.IndexSettings;IndexSettings(IndexMetaData, Settings, Predicate<String>, IndexScopedSettings);[238];[246, 269];Added the initialization to the globalCheckPointInterval field getting from scopedSettings map;Added the initialization to the maxRefreshListeners field getting from scopedSettings map and added a call to addSettingsUpdateConsumer for the key that got the maxRefreshListeners;No;False;LEFT adjusts a single initialization in the constructor (e.g., how a setting like the parse field matcher or a specific setting is retrieved), while RIGHT changes two other lines in the same constructor (e.g., different settings initializations or adding settings update consumers). The modified lines affect different state fields and do not compute conflicting values for the same state. The merged constructor preserves both changes’ behaviors without altering unchanged base behavior.
11;elasticsearch;d896886973660785aac45275ddb110c1a6babc57;org.elasticsearch.action.bulk.TransportShardBulkAction;update(IndexMetaData, BulkShardRequest, IndexShard, long[], VersionType[], Translog.Location, int, BulkItemRequest);[268, 255];[244, 249, 266, 254];Added the parameter seqNo to both calls of the UpdateResopnse constructor;Added a SupressWarning annotation twice and refactored the WriteResult class to return its parameters via getResponse and getLocation (Refactor);No;False;Both sides modify the update() path around response/opType handling and error/retry branches without changing the executed operations, versioning, or translog location updates. The merged behavior remains consistent (responses/reporting only), so no state element is computed differently and there is no semantic interference.
12;elasticsearch;d896886973660785aac45275ddb110c1a6babc57;org.elasticsearch.action.support.replication.TransportReplicationAction;doRun();[455, 458, 460];[457, 459];Left creates a new local variable, and assigns a value to it depending on a try, which was also changed by Left.;Right adds a new local variable and assings a value to it inside a try, which was chaged by Left.;Yes;False;"Both changes touch the replica doRun() path around constructing and returning the ReplicaResponse. LEFT adjusts lines related to executing the replica op and building the response; RIGHT tweaks nearby lines (e.g., ordering/logging/asserts). In both, the flow remains: acquire replica lock, run shardOperationOnReplica, build ReplicaResponse with allocationId and local checkpoint, release lock, and respond via listener. No altered state or behavior is lost in the merge; overall semantics are preserved."
13;elasticsearch;d896886973660785aac45275ddb110c1a6babc57;org.elasticsearch.action.support.replication.ReplicationOperation;execute();[98, 109];[113, 98, 99, 101, 119, 108, 110];Left creates a new local variable primaryRounting, while it also adds a new call for updateLocalCheckpointForShard on the field primary.;Right creates a new local variable primaryRounting and renames the local variable primaryId. It also adds a new call for replicaRequest on the field primaryResult.;No;False;"Both sides modify the same region of execute() but in compatible ways. LEFT is limited to small adjustments around the primary-related variables/calls (e.g., using the existing primary routing/local node id and related bookkeeping), while RIGHT tweaks nearby lines affecting how the local node id is obtained and/or replica dispatch conditions/logging. Neither side alters the core control flow: perform on primary, update the primary’s local checkpoint, compute the shard list, skip local primary, send to non-local replicas and relocation targets, maintain total/successful/pending counters, and finish. No state element (totalShards, pendingShards, successfulShards, primaryResult, shardReplicaFailures, or checkpoint updates) is computed differently in a way that would break the behavior of either change; thus, there is no semantic interference."
14;elasticsearch;d896886973660785aac45275ddb110c1a6babc57;org.elasticsearch.index.engine.InternalEngineTests;testRecoverFromForeignTranslog();[2091];[2124];Left updates the method call for creating a new Index object. Now, it is also assigned a value for field seqNo.;Right updates the method call for creating a new EngineConfig object. Now, it is also assigned a value for field refreshListeners.;No;False;"LEFT changes a single line around building the foreign translog entry (likely a non-functional cleanup such as using StandardCharsets.UTF_8 instead of Charset.forName). RIGHT changes a later line in the test (likely adjusting the assertion/exception expectation style). They touch different lines and do not alter the test’s logic: it still creates a translog with a different UUID and asserts that opening the engine with it fails, then recovers with the correct translog. The combined result preserves both behaviors; no semantic interference."
15;elasticsearch;d896886973660785aac45275ddb110c1a6babc57;org.elasticsearch.index.engine.InternalEngine;InternalEngine(EngineConfig);[134];[161, 162, 163, 164];Left adds a new field in the class, and also assigns a value for it in the constructor.;Right adds a new IF statement, which whether a property on the object engineConfig is nulll.;No;False;LEFT adds a single-line change in the constructor (likely initializing a new SequenceNumbersService or a similar field), while RIGHT adds a small block (registering refresh listeners with the SearcherManager and wiring the translog to them). These changes touch different concerns and do not alter each other’s behavior or the base behavior. The merged constructor (showing both seqNoService initialization and refresh listeners setup) preserves both behaviors without interference.
16;elasticsearch;d896886973660785aac45275ddb110c1a6babc57;org.elasticsearch.action.DocWriteResponse;writeTo(StreamOutput);[140];[141];Left adds a call for method writeZLong on the out object sending a long value.;Right adds a call for method writeBoolean on the object out sending a boolean value.;Yes;False;Left modified the serialization of one field in writeTo (likely the version), while Right modified the following line (likely the seqNo). These affect different state elements written to the stream and do not change shared control flow or ordering. Integrating both changes preserves each side’s behavior, so there is no semantic interference.
17;elasticsearch;d896886973660785aac45275ddb110c1a6babc57;org.elasticsearch.action.DocWriteResponse;readFrom(StreamInput);[129];[130];Left adds a call for method readZLong on the in object.;Right adds a call for method readBoolean on the object in.;No;False;"Left modified how the version field is read; Right modified how the seqNo field is read. These changes affect different state elements (version vs. seqNo) and keep the same read order. They do not overwrite or depend on each other, so both altered behaviors can coexist. Assuming writeTo uses matching encodings per field, there is no semantic interference."
18;elasticsearch;d896886973660785aac45275ddb110c1a6babc57;org.elasticsearch.action.DocWriteResponse;toXContent(XContentBuilder, Params);[163, 164, 165, 166];[160];Left adds two calls for method field on the object builder.;Right adds a call for method field on the object builder.;Yes;False;Left modifies the tail of toXContent by changing the fields emitted after shardInfo (likely removing the temporary internal _shard_id field and/or adjusting conditional emission of _seq_no). Right changes an earlier single field emission around line 160 (one of _index/_type/_id/_version/forced_refresh). These changes affect different output fields and do not overlap in logic or state, so the merged result can preserve both sides’ intended behavior without altering the base behavior elsewhere.
19;elasticsearch;d896886973660785aac45275ddb110c1a6babc57;org.elasticsearch.cluster.metadata.MetaDataCreateIndexService;createIndex(CreateIndexClusterStateUpdateRequest, ActionListener<ClusterStateUpdateResponse>);[315];[304, 305, 309, 310, 312, 346, 300];Left adds one new parameter when creating the local variable indexService.;Right extracts a local variable (refactoring) and also adds a new local variable routingNumShards.;No;False;RIGHT adds/adjusts logic around request settings normalization/validation and routingNumShards handling (including shrink-index support and setting routingNumShards on IndexMetaData builders). LEFT modifies a single line around that area (likely a cosmetic/no-op fix such as an extra semicolon or minor formatting) without changing the behavior. The merged code preserves RIGHT’s functional changes and LEFT’s tweak does not alter computed state (e.g., settings, mappings, aliases, routingNumShards). Therefore, there is no semantic interference.
20;elasticsearch;d896886973660785aac45275ddb110c1a6babc57;org.elasticsearch.action.update.TransportUpdateAction;shardOperation(UpdateRequest, ActionListener<UpdateResponse>, int);[224, 185, 254];[192, 249, 250];Left adds new parameters when creating the local variable update.;Right sets the field forcedRefresh of the local variable update;No;False;The LEFT and RIGHT changes affect different aspects of shardOperation: LEFT adjusts behavior around upsert get-result computation and/or retry logging, while RIGHT propagates additional response metadata (e.g., seqNo/forcedRefresh) and/or minor NONE-case handling. These modifications are orthogonal and do not change or override each other’s logic. The merged result preserves both behaviors without altering the base program’s unchanged semantics.
21;elasticsearch;d896886973660785aac45275ddb110c1a6babc57;org.elasticsearch.action.delete.TransportDeleteAction;executeDeleteRequestOnPrimary(DeleteRequest, IndexShard);[136];[140];Left sets the field seqNo on object request, and added this value on the call to create the returned object DeleteResponse.;Right does a refactoring by extracting a variable, and them call the method to create the method return object.;No;False;LEFT changes adjust the state carried in the DeleteRequest after executing on the primary (e.g., updating replication-related metadata such as version/seqNo). RIGHT changes modify how the DeleteResponse is constructed (e.g., which fields from the Engine.Delete are used in the response). These affect different state elements: request propagation to replicas vs. response contents. They do not override each other or change the same computed value, so the merged behavior preserves both sides’ intents without interference.
22;elasticsearch;3764b3ff800c94293aba0bb0fa18c7df80a764f7;org.elasticsearch.rest.action.cat.RestNodesAction;getTableWithHeader(RestRequest);[];[153, 154, 156, 157, 158, 159];Removed calls to a method that modifies the table object;Changed parameters passed to a method that modifies the table object;No;False;LEFT made no changes to the method. RIGHT modified a few header definitions (likely aliases/descriptions) in getTableWithHeader without altering the row-building logic. Since table rows are added positionally and LEFT did not change behavior, integrating RIGHT’s changes preserves intended behavior and does not cause semantic interference.
23;elasticsearch;3764b3ff800c94293aba0bb0fa18c7df80a764f7;org.elasticsearch.rest.action.cat.RestIndicesAction;getTableWithHeader(RestRequest);[];[144, 147, 150, 153, 138, 141];Removed calls to a method that modifies the table object;Changed parameters passed to a method that modifies the table object;No;False;"LEFT made no changes. RIGHT modified only header metadata (column definitions/aliases/descriptions) in getTableWithHeader; no logic or data computation was changed. Integrating these changes preserves RIGHT’s behavior and does not interfere with LEFT or the base program’s unchanged computations."
24;elasticsearch;3764b3ff800c94293aba0bb0fa18c7df80a764f7;org.elasticsearch.rest.action.cat.RestShardsAction;getTableWithHeader(RestRequest);[];[112, 113];Removed calls to a method that modifies the table object;Changed parameters passed to a method that modifies the table object;No;False;"LEFT made no changes. RIGHT modified two header-definition lines in getTableWithHeader, likely adjusting column metadata (e.g., names/aliases/descriptions) for the cat shards output. Since only RIGHT changed the method and LEFT did not, there is no interference; the merged behavior equals RIGHT’s behavior and preserves base behavior elsewhere."
25;elasticsearch;0404db65e3497452886173957729c8e82cfd4a03;org.elasticsearch.test.ESSingleNodeTestCase;newNode();[171];[173, 174];"Changed the key parameter passed 
to put, to a constant with the same value (Extract variable)";"Changed the key parameter passed 
to two other puts, to a constant with the same value (Extract variable)";No;False;Left modified one setting in newNode (likely the scripting configuration for inline scripts), while Right modified the two adjacent scripting settings (renaming/adjusting script.indexed to script.stored and updating inline). Both changes target scripting permissions for the test node and are compatible. The merged result continues to enable scripting as intended and does not alter unrelated node behavior. No state element is computed differently in the merge compared to Left or Right individually, so there is no semantic interference.
26;elasticsearch;59cb67c7bd0ab6311115b20954e013412b676b29;org.elasticsearch.index.query.support.NestedInnerQueryParseSupport;setPathLevel();[193, 195, 197, 200];[199];"Left adds a new field, and use it to assign values for fields parentFilter and parentObjectMapper; it has the same behavior when compared to base commit.";Right changes the value assigned to childFilter;No;False;"Left updates the logic that sets the parent filter and parent object mapper (and possibly also adjusts the child filter line) to correctly reflect the current nested scope, while Right only tweaks the childFilter assignment (likely a performance/caching or API adjustment). These changes address different concerns: Left ensures correct parent/child scoping via bitset filters and scope advancement; Right preserves the semantics of childFilter while changing its construction. Integrated, they continue to produce the same parent/child scoping behavior, so there is no semantic interference."
27;elasticsearch;59cb67c7bd0ab6311115b20954e013412b676b29;org.elasticsearch.index.query.MultiMatchQueryBuilder;doXContent(XContentBuilder, Params);[306, 367];[];"Changed the parameter sent to the startObject method but the value of the parameter remained the same;

Removed two if conditions that made calls to the field method by passing (""boost"", boost) and (""_name"", queryName).

Added a call to the printBoostAndQueryName method passing the builder object as a parameter.";Removed an if condition (rewrite! = Null) that used the field method of the builder object;Yes;False;"Only the LEFT developer modified doXContent at the location of interest; the RIGHT developer made no changes there. The merge will therefore include LEFT’s serialization changes without interference. No state element differs between B/L/R versus Merge due to RIGHT, so there is no semantic conflict."
28;elasticsearch;f3d63095dbcc985e24162fbac4ee0d6914dc757d;org.elasticsearch.index.analysis.synonyms.SynonymsAnalysisTest;testSynonymsAnalysis();[65, 66, 67, 68, 69, 70, 71, 76];[73, 75];"Left extracts a local variable home of the parameter used on method put. Now, it's used the return of createTempDir instead of createTempDir().toString();";Right extracts a local variable json from the parameter sent to method loadFromStream. It also replaced the method call loadFromClasspath to loadFromStream, which is done by the method return object of settingsBuilder.;No;False;Left changes adjust the test setup/injection and modify the final assertion (line ~76), while Right changes update the expected outputs for the second and fourth match calls (lines ~73 and ~75). These modifications touch different parts of the test (setup and a different subset of assertions) and do not alter the same state or expectation. When merged, both behaviors (service initialization and the specific expected outputs) are preserved, so there is no semantic interference.
29;elasticsearch;f3d63095dbcc985e24162fbac4ee0d6914dc757d;org.elasticsearch.index.analysis.commongrams.CommonGramsTokenFilterFactoryTests;testQueryModeCommonGramsAnalysis();[229];[226, 228];Replaced the call to the createTempDir().toString() method with createHome();"Added a variable called Json containing a String with the path to the file commongrams_query_mode.json;
Replaced the loadFromClasspath method with loadFromStream;";No;False;LEFT changes adjust the test input line inside testQueryModeCommonGramsAnalysis (e.g., the source string), affecting only what the test asserts. RIGHT changes refactor how the analyzer is obtained (e.g., removing an extra .analyzer() call) without changing behavior. These touch different concerns: test data vs. API usage. The combined result preserves both behaviors, so there is no semantic interference.
30;elasticsearch;f3d63095dbcc985e24162fbac4ee0d6914dc757d;org.elasticsearch.index.analysis.commongrams.CommonGramsTokenFilterFactoryTests;testCommonGramsAnalysis();[144];[141, 143];"Left changed the local settings variable with a call to put() method in settingsBuilder(), which uses the local variable called ""json"" changed by right.";Right changed the local variable json. Changed the local varibale called settings with a call to loadFromStream() method in settingsBuilder();No;False;RIGHT changes modify how the Analyzer is retrieved/constructed within the test (e.g., refactoring analysisService.analyzer(...).analyzer() to a direct Analyzer), while LEFT changes adjust a different line in the method (likely settings/build or test data). These edits affect different aspects and do not change the expected analysis output or settings semantics. The merged code preserves both sides’ intended behavior, so there is no semantic interference.
31;elasticsearch;f3d63095dbcc985e24162fbac4ee0d6914dc757d;org.elasticsearch.index.analysis.KuromojiAnalysisTests;createAnalysisService();[196, 197, 198, 199, 200, 201, 202, 206];[204, 207];"Left changed the local settings variable with a call to put() method in settingsBuilder(), which uses the local variable called ""json"" changed by right.
Changed other local variables: empty_dict, dict, home, config and Files, not used by right.";Right changed the local variable json. Changed the local varibale called settings with a call to loadFromStream() method in settingsBuilder();No;False;Left modified the setup of settings and environment in createAnalysisService (home/config paths, copying resources, building Settings, possibly version setting). Right made small adjustments to module/injector construction (e.g., AnalysisModule or injector creation). These changes affect different parts of the method and are orthogonal: settings preparation vs. dependency injection wiring. The merged result preserves both behaviors, and no state element (e.g., Settings, AnalysisModule, AnalysisService) computes a different value than in either side individually.
32;elasticsearch;36884807b3cc9d660db4da062275c7fdbec8ba67;org.elasticsearch.index.query.SimpleIndexQueryParserTests;setup();[217];[208];Left set the fields type and id on the local variable doc. Refactoring;Right adds a new entry on the local obecjt settings.;No;False;Both changes touch different lines within the setup() method and affect independent aspects of the test initialization (settings vs. mapping/put-mapping details). They do not compute conflicting values for the same state element: the index settings (e.g., cache configuration or node name) and the mapping/dynamic mapping application remain compatible when combined. The resulting index creation and query parser acquisition behave consistently, so there is no semantic interference.
33;elasticsearch-river-mongodb;3d4f99516ba3177f7d88a1f600923138a8b77cc8;org.elasticsearch.river.mongodb.Slurper;assignCollections();[288, 289, 290, 322, 291, 292, 293, 294, 295, 297, 298, 286, 287];[315, 331, 302];Left adds some if statements and changed the values of two variables: adminDb and oplogDb.;Right changes the value of oplogRefsCollection by calling a method of oplogDb;Yes;False;Left adds support for selecting admin/local authentication databases and related logging at the beginning of assignCollections(). Right adjusts later parts of the method (likely authentication flow or DB selection/logging). Both changes are complementary: authentication is performed on the configured databases and the oplog/slurped DBs are then set consistently. No state (oplogDb, slurpedDb, collections, or return value) is computed incompatibly, so the merged behavior preserves both sides’ intent.
34;elasticsearch-river-mongodb;6b6ce8e851c6613213c4508c3f277a80649e0c7b;org.elasticsearch.river.mongodb.MongoDBRiverDefinition;parseSettings(String, String, RiverSettings, ScriptService);[534, 646, 535, 536, 538, 539, 540, 541, 526];[561, 500, 567, 602, 475, 620, 655];Left changes the parameter used to assgin a value to field socketTimeout on local variable builder, sets the field isMongos on builder, and adds a new parameter used to instantiate the local variable scriptExecutable.;Right replaces the method calls of logger.info to logger.trace, and logger.warn to logger.error.;No;False;LEFT and RIGHT modify different concerns inside parseSettings. LEFT adjusts the MongoDB options area (likely around SSL handling/verification and related option parsing), while RIGHT adjusts parsing of indexing/bulk settings (e.g., bulk size/concurrency, throttle) and other unrelated options. They do not compute or assign different values to the same state elements. The merged result preserves both behaviors without altering unchanged base behavior.
35;elasticsearch-river-mongodb;3d4f99516ba3177f7d88a1f600923138a8b77cc8;org.elasticsearch.river.mongodb.MongoDBRiverDefinition;parseSettings(String, String, RiverSettings, ScriptService);[714, 699, 683, 717, 686, 703];[576, 515, 582, 617, 490, 635, 670];Left sets two fields on local variable builder.;Right replaces the method calls of logger.debug to logger.trace, and logger.warn to logger.error.;No;False;"LEFT modifies the index/bulk configuration handling near the end of parseSettings (e.g., bulk actions/size/flush interval/concurrent requests and throttle size defaults). RIGHT updates earlier parts of parseSettings related to MongoDB options and credentials (e.g., adds/uses auth database in credentials, SSL/read preference/options parsing). These changes affect different builder fields and code paths; the merged result preserves both behaviors without altering the other side’s semantics. No state element is computed inconsistently between B, L, R, and Merge."
36;elasticsearch-river-mongodb;6b6ce8e851c6613213c4508c3f277a80649e0c7b;org.elasticsearch.river.mongodb.Indexer;applyAdvancedTransformation(QueueEntry, String);[321];[288, 358, 331, 287];Left adds a new parameter used to instantiate the local variable scriptExecutable.;Right changes a IF verification and replaces method calls of logger.debug for logger.trace;No;False;Left changed a single line in applyAdvancedTransformation, affecting how the script context/document is prepared. Right modified several lines in the same method and related helpers, affecting how the transformed items are read (e.g., extracting id/type/routing/parent, and possibly defaulting operation). The changes target different aspects (context creation vs. consumption and extraction) and appear complementary: Left’s adjustment to how documents are placed into the context pairs with Right’s adjustments to how they are read back. There’s no indication that the merged code would compute different values for shared state compared to either side’s intended behavior, so no semantic interference.
37;elasticsearch-river-mongodb;6b6ce8e851c6613213c4508c3f277a80649e0c7b;org.elasticsearch.river.mongodb.Indexer;processBlockingQueue(QueueEntry);[176];[161, 198, 201, 189];Left adds a new parameter on constructor to instatiate the local variable executableScript.;Right replaces some method calls of logger.debug to logger.trace, and also removes an old call to write on logger (logger.debug). It assigns a hashmap object to local variable ctx.;No;False;"LEFT adjusts a single line around local data/context handling in processBlockingQueue (likely a non-behavioral change such as safer map creation/typing). RIGHT modifies separate spots that deal with extracting and applying script-derived fields (index/type/routing/parent/objectId/operation) and guarding behavior. These touch different aspects of the method and are complementary: LEFT’s change does not alter control flow or decisions, while RIGHT’s change refines how values are read and applied. The merged code preserves both sides’ intended behavior and the base behavior; no state element gets a different value due to the combination."
38;elasticsearch-river-mongodb;6b6ce8e851c6613213c4508c3f277a80649e0c7b;org.elasticsearch.river.mongodb.Slurper;run();[105];[145, 148];Left adds a new IF statement, which could restrict the assginment value for the local variable startTimestamp.;Right replaces the method calls of logger.warn for logger.error;No;False;"LEFT likely changed a log line around skipping the initial import; RIGHT adjusted log statements in the cursor-not-found handling. Both modifications affect logging only and do not alter control flow, data processing, or state. The merged behavior of run() remains the same, so there is no semantic conflict."
39;elasticsearch-river-mongodb;6b6ce8e851c6613213c4508c3f277a80649e0c7b;org.elasticsearch.river.mongodb.Slurper;addToStream(Operation, Timestamp<?>, DBObject, String);[752, 747, 748, 751];[736, 737, 738, 739, 740, 741, 742, 743];Left adds new calls for writing on logger (logger.info).;Right adds a new call for writing on logger.;Yes;False;"LEFT adds behavior for Operation.DROP_DATABASE to enqueue DROP_COLLECTION events (for all or a single collection). RIGHT changes the tracing in addToStream (e.g., how data is logged) without altering the enqueued operations. The changes touch different concerns (queue behavior vs. logging) and do not alter the same state. Integrating both preserves LEFT’s new DROP_DATABASE handling and RIGHT’s logging adjustments; no semantic interference."
40;fitnesse;4d9ba9d221d879507440feb084fa7521b95111ec;fitnesse.testsystems.slim.tables.SlimTableFactory;SlimTableFactory();[24, 25];[31];Left adds two new elements into a map, by calling the add method addTableTye twice.;Right adds a new element into a map, also calling the method addTableType.;Yes;False;Left changes adjust the map initialization in the constructor (e.g., capacity/implementation of the maps), affecting only performance/ordering but not lookup semantics. Right change updates a single addTableType entry (adding/modifying a table type prefix). These modifications are orthogonal: the new/changed mapping works regardless of the map's initial capacity/implementation. The merged result preserves both behaviors with no state element computing a different value than in Left or Right.
41;fitnesse;4d9ba9d221d879507440feb084fa7521b95111ec;fitnesse.testsystems.slim.tables.SlimTableFactoryTest;setUp();[32, 31];[38];Left adds two entries on the field map.;Right adds one entry on the field map.;Yes;False;LEFT updates two alias mappings for DecisionTable (e.g., dt:/dT:), while RIGHT updates the mapping for the query: alias. These touch different keys in the map and do not override each other. The merged setUp() simply contains all updated mappings, preserving both sides’ intended behavior with no state element computed differently.
42;hector;0588608e7a2bdf974c985ff546207104f672bf6c;me.prettyprint.cassandra.connection.client.HSaslThriftClient;open();[96, 97, 94, 111, 95];[122];Left changed the local variable 'socket', inserting a try catch and changed the transport attribute.;Right changed the 'transport' variable and used it as a parameter for a method.;No;False;"LEFT modifies socket creation in open(), adding conditional SSL (TSSLTransportFactory) and related adjustments around those lines. RIGHT changes a single line later in open() (around line 122), likely adjusting the argument to openKerberosTransport (e.g., service principal handling) or a minor behavior such as logging/timeout. These touch different concerns: LEFT affects how the socket is created; RIGHT affects the parameter used for SASL/Kerberos transport. In the merged result, both behaviors can co-exist: the socket (possibly SSL) is still created as LEFT intended, and the Kerberos call uses RIGHT’s intended value. No state element is computed inconsistently between B, L, R, and the Merge, so there is no semantic interference."
43;hector;a33a46506656a39d1b0f7780973905665d3b6145;me.prettyprint.cassandra.connection.client.HKerberosThriftClient;open();[88];[69, 70, 71, 72, 73, 74, 75, 76];Left changed the transport statement using the socket variable (changed by right).;Right added a try catch to check if 'param' was null, changing the socket statement.;No;False;LEFT changes how the Thrift transport is created from the socket (e.g., wrapping strategy), while RIGHT changes how the socket is obtained/configured (e.g., creation/SSL/timeout). These affect different stages (socket creation vs. transport wrapping) and compose without altering each other’s behavior, so the merged code preserves both changes.
44;hector;213f7887ea70eabdf0705cf8454de29af89e8c38;me.prettyprint.cassandra.connection.HConnectionManager;operateWithFailover(Operation<?>);[267, 268];[200];Left changed the log level from log.error() to log.warn().;Right changed the creation of a local variable called 'stopWatch', changed the creation of a new instance with 'new', calling a method that returns an existing instance (stopWatchFactory.getStopWatch()).;No;False;RIGHT changes the initial retry count (e.g., how many times to retry), while LEFT modifies the failure accounting in the finally block (stopwatch tag and/or fail counter behavior). These affect different concerns—retry logic vs. metrics/logging—and do not alter the same state elements. Merging preserves both: retries are computed per RIGHT, and failure logging/stopwatch behavior per LEFT. No semantic interference.
45;hector;a33a46506656a39d1b0f7780973905665d3b6145;me.prettyprint.cassandra.connection.client.HThriftClient;open();[164];[147, 148, 149, 150, 151, 152, 169, 153, 154];Left changed the transport statement using the socket variable (changed by right).;Right added a try catch to check if 'param' was null, changing the socket statement. And added a condition to check that the 'transport' attribute was not open (! Transport.isOpen ()).;No;False;Both developers changed the open() method but in orthogonal ways. RIGHT modified several lines around socket creation, SSL handling, and guarding transport.open() (including improved error handling) so that SSL sockets already connected are not reopened. LEFT changed a single line later in the method (likely around wrapping the socket into a TFramedTransport or the isOpen check). These do not alter each other’s intended behavior: the connection is created (possibly via SSL), keepalive may be set, the transport is wrapped if configured, and transport.open() is only called when not already open. No state element ends up with a different value compared to either individual change, so there is no semantic interference.
46;HikariCP;1bca94af9ec625f21d1b58ff10efb5be71ab87a6;com.zaxxer.hikari.HikariPool;addConnection();[356, 372, 374, 365];[339, 340, 341, 342, 343, 344, 345, 362, 346, 348];Left adds a new verification an an IF condition, does a refactoring for an old IF, and also adds a call for a local method.;Rights changes the assigment to local variable retries, adds some new IF statements, and sets the field loginTimeout on datasource.;Yes;False;"Right changes adjust the acquisition/login-timeout and the speculative increment logic for totalConnections around connection creation, while Left changes modify the connection initialization path (ordering of init SQL, transaction isolation capture, and/or reset of connection state) after obtaining the physical connection. These touch different concerns: Right affects timing/counting before or at connection acquisition; Left affects preparing the connection after acquisition. No shared state is altered in contradictory ways, and the merged result can preserve both the Right behavior for totalConnections/loginTimeout and the Left behavior for connection initialization. Hence, no semantic merge conflict."
47;HikariCP;1bca94af9ec625f21d1b58ff10efb5be71ab87a6;com.zaxxer.hikari.HikariConfig;validate();[577, 578, 579, 580, 581, 582];[];Left adds a new IF statement, which may write in logger calling method info;Right removes source code, which would write in logger calling method error or wanr, or even trhows an exception. Changes on formating;Yes;False;Only the LEFT developer modified validate() (lines 577–582), while the RIGHT developer made no changes. Therefore, the merge simply incorporates LEFT’s behavior with no competing modifications. There is no state x for which LEFT and RIGHT compute different values, and the merged result preserves LEFT’s altered behavior.
48;java-faker;ca42fcfaf45cae1754c58e02e1d5d2a58ec03561;com.github.javafaker.Faker;Faker(Locale, Random);[69, 59];[70];Left adds an initialization of two fields on constructor.;Right changes the initialization of a different field.;No;False;"Left adjusts the construction of the fallback FakeValuesService to use the Locale.ENGLISH constant (style/clarity) and/or minor local variable adjustments; Right tweaks the proxied service creation line (likely variable naming/order/static reference). Both changes are within the Faker(Locale, Random) constructor but affect different aspects of setting up the same services. All fields (app, lorem, name, etc.) still receive the same dependencies and behavior (primary locale with English fallback). No state element is computed differently compared to either side, so there is no semantic interference."
49;jenkins;48b2b951dfb3438999ceda330093cac82b857ce6;jenkins.slaves.DefaultJnlpSlaveReceiver;handle(String, JnlpSlaveHandshake);[52];[52, 56, 57];Left changed the return of a condition from false to true.;Right added an IF, checking if !MatchesSecret (nodeName, handshake) is true, changing the error message of the handshake attribute and error method, then returning true.;Yes;False;"Left touched the rejection path when an agent is already connected (line ~52), likely adjusting the message or minor handling, while Right modified the same message and the secret-check branch (lines ~56–57), likely updating terminology or the error text. Control flow remains the same: reject if already connected (without matching cookie) or if the secret mismatches; otherwise generate a cookie, succeed the handshake, and connect the channel. No state or decision logic changes, so the merged code preserves behavior with no semantic interference."
50;jsoup;fee4762322f85a1109edd75ccb67f38cf5008c80;org.jsoup.helper.HttpConnection;createConnection(Connection.Request);[609, 610, 611, 612, 613, 614];[617];Left adds a IF statement, allowing extra set fields of the object returned by the method;Rights changes a IF condition, setting more fields of the object returned by the method and accepting more values than before;No;False;LEFT modifies the HTTPS handling in createConnection: when the request targets HTTPS and certificate validation is disabled, it installs an insecure SSLSocketFactory and HostnameVerifier. RIGHT changes a different part of createConnection (e.g., header/property setting or output flag around line 617). These concerns are orthogonal (SSL setup vs. request properties/body handling), affect different state elements, and can coexist without altering each other’s intended behavior or the base behavior. Hence, no semantic merge conflict.
51;jsoup;a8b6982de98ff76ef254031d7152fff57f6bf941;org.jsoup.helper.HttpConnection;execute(Connection.Request, Response);[584, 585, 586];[544, 547];Left changes the value assigned to the local variable bodyStream, and also removes the local variable dataStream. The object bodyStream uses the object conn, that is created based on req (changed by Right).;Right adds a new verification before calling some methods of the parameter req.;Yes;False;LEFT changes (lines ~584-586) adjust handling of zero-length/absent response bodies, ensuring res.byteData is set to an empty buffer when no content is available. RIGHT changes (lines ~544-547) adjust parser selection based on the response Content-Type, switching to the XML parser when appropriate if no parser was explicitly set. These modifications affect different state elements (response byteData vs. parser selection) and execution phases (body reading vs. parser choice). They do not override or invalidate each other, and the merged behavior preserves both changes without altering unchanged base behavior.
52;jsoup;3f7d2c71dbbbb289c684f339874eed8ac2747fa0;org.jsoup.helper.HttpConnection;execute(Connection.Request, Response);[456];[483, 484, 485];Left adds a new condition (OR) that is reponsible for changing the value of the local variable needsRedirect.;"Right updates another if statement conditions; it changes a set of conditions grouped with AND, to the OR operator. This if is responsible for throw a new exception.";Yes;False;"LEFT modifies a single line in execute(Request, Response) affecting redirect handling (e.g., method/data handling on redirect). RIGHT modifies three lines that normalize/handle the Location header during redirects. Both touch the redirect path but affect different aspects (request method/data vs redirect URL processing). These changes are orthogonal and can coexist without altering each other’s intended behavior or the base behavior; no state element is computed inconsistently in the merge."
53;jsoup;a44e18aa3c1fcd25a68a5965f9490d8f7d026509;org.jsoup.nodes.TextNode;outerHtmlHead(StringBuilder, int, Document.OutputSettings);[94];[98];"Left changes the condition of an if statement, which calls the method preserveWhitespace. Now the method only performs its verifications if the node is not null and is an instance of Element type; otherwise, no action is performed and the value of local variable html is not updated.";Right adds a new condition (OR) in an if statement, which may change the value of the parameter accum.;Yes;False;Left changes the indentation/pretty-print condition (when to indent a text node). Right changes how the text is appended (e.g., whitespace handling when appending). They touch different parts of outerHtmlHead: Left on the indent decision (line ~94), Right on the final append (line ~98). These behaviors compose: the node is indented per Left’s rules and the text content is appended per Right’s rules. No altered behavior is lost and no base behavior is contradicted, so there is no semantic conflict.
54;libgdx;da27e2dae56be0a159e82231e5c3a5b83b099063;com.badlogic.gdx.backends.lwjgl3.Lwjgl3Application;newWindow(ApplicationListener, Lwjgl3WindowConfiguration);[318];[325];Left changes four attributes of an object using a set method;Right uses a set method to change the value of an object's attribute;No;False;Left modified the configuration passed to the new window (e.g., forwarding a specific window property from Lwjgl3WindowConfiguration to the copied Lwjgl3ApplicationConfiguration), affecting only how the window is configured (size/limits/visibility/title/decorations, etc.). Right modified the createWindow invocation (e.g., which context to share or how the window is added), affecting the GL context sharing/creation aspect. These touch different concerns (window config vs. context creation) and do not compute or overwrite the same state element, so their behaviors can coexist without interfering with each other.
55;libgdx;da27e2dae56be0a159e82231e5c3a5b83b099063;com.badlogic.gdx.backends.lwjgl3.Lwjgl3ApplicationConfiguration;copy(Lwjgl3ApplicationConfiguration);[96, 97, 98, 99];[107];Left assigns new values ​​from the method parameter to four different attributes of the object.;Right assigns a new value from the method parameter to an attribute of the object.;No;False;"Left modified the copy() method around the tail assignments (likely switching initialBackgroundColor to a deep copy and possibly adjusting nearby fields like title/visibility/preferences). Right modified a different assignment later in the method (likely the hdpiMode copy/null-handling). These changes affect different state fields and do not interfere; merging preserves both behaviors."
56;logback;542843fd04a793fb9e0eea0c84d199e66d7c15af;ch.qos.logback.core.rolling.TimeBasedFileNamingAndTriggeringPolicyBase;start();[45];[52, 53, 54, 55, 56];Extracted a variable from constructor DateTokenConverter creating a Object object (Refactor) called dtc.;Created a condition with the dtc object, checking if getTimeZone is different from null and returning an instance of the RollingCalendar object.;Yes;False;LEFT adds a start-related change (likely setting the 'started' flag to true) at the end of start(). RIGHT adjusts the initialization logic around dateInCurrentPeriod/nextCheck (e.g., using the existing log file's lastModified time if available). These touch different state elements: LEFT affects 'started', RIGHT affects 'dateInCurrentPeriod' and 'nextCheck'. The merged behavior preserves both changes and the base behavior, so there is no semantic interference.
57;MPAndroidChart;af114d180da6ec5633d32c701ff5467f7629fcf3;com.xxmassdeveloper.mpchartexample.fragments.SimpleFragment;generateScatterData(int, float, int);[80, 91];[73];"Changes the values passed to the Entry class constructor, inverting the passed parameters, that changes inteferes with a call to setScatterShape modifying an attribute on the ScatterDataSet class . Removes the value ""ChartData.generateXVals(0, count)"" from the ScatterObject creation";"Changes the method that initializes the shapes array to ""ScatterChart.ScatterShape.getAllDefaultShapes()"" that adds new shapes to the shapes variable";No;False;LEFT adjusts properties inside the loop (e.g., scatter shape size and/or colors around lines 80 and 91), while RIGHT changes how the array of shapes is obtained/defined (around line 73). These affect different attributes of the ScatterDataSet (shape type vs. size/color) and do not interfere. The merged result can simultaneously use RIGHT’s shape selection with LEFT’s size/color changes, preserving both behaviors.
58;MPAndroidChart;af114d180da6ec5633d32c701ff5467f7629fcf3;com.xxmassdeveloper.mpchartexample.ScatterChartActivity;onProgressChanged(SeekBar, int, boolean);[178, 168, 188, 204, 173, 205];[183, 186, 191];Left made changes to yVals1, yVals2, and yVals3, then also altered the same object set2 from right but in different attributes. Finally, left modifies the data object, which contains a list with set1, set2, and set3.;Right made changes to set1, set2, and set3, which were created using yVals but are elements of different states. Both sides preserved each other's changes.;No;True;Left adjusts the label to show mSeekBarX.getProgress() (removing +1) and keeps the data size logic unchanged, while Right changes the three loops to produce mSeekBarX.getProgress()+1 entries (to match the original +1 label). When merged, the chart will create progress+1 entries but tvX will show progress, reintroducing a mismatch different from both Left and Right intentions. This alters the behavior of both the label and dataset size relative to B, L, and R, hence a semantic conflict.
59;MPAndroidChart;af114d180da6ec5633d32c701ff5467f7629fcf3;com.xxmassdeveloper.mpchartexample.ScatterChartActivity;onCreate(Bundle);[80, 86, 77, 63];[57];Left refactored by renaming tf to mtfLight and moved the variable initialization to the onCreate method of the superclass. And writes to maxHighlightDistance, and right writes to shapeRendererList.;Right writes to shapeRendererList.;No;False;Left modifies multiple chart configuration lines in onCreate (legend/axes/grid or related styling/limits), while Right changes a different single configuration line earlier in onCreate (likely a touch/highlight/interaction parameter). They affect different chart properties (distinct state elements), so when merged, both behaviors coexist and do not override each other. No altered behavior from either side is lost, and unchanged base behavior is preserved.
60;MPAndroidChart;9297923f09460d0484cd713b0abbeaea9b888ec0;com.xxmassdeveloper.mpchartexample.LineChartActivity2;onCreate(Bundle);[126];[117];Added a call to the setDrawZeroLine method setting the value for the field mDrawZeroLine at the rightAxis object as false.;Deprecated the method setStartAtZero from the YAxis class, and removed the call for it on the rightAxis object. Added a call to the method setAxisMinValue on the left axis object;No;False;"LEFT changed code around line ~126 in onCreate, which is in the YAxis configuration block (e.g., right/left axis range/grid/zero-line). RIGHT changed code around line ~117, which is in the legend/XAxis configuration area. These target different chart components and state elements; both settings can coexist and will be applied independently by the chart API. The merged program preserves both behaviors and the base behavior elsewhere, so there is no semantic interference."
61;MPAndroidChart;9297923f09460d0484cd713b0abbeaea9b888ec0;com.xxmassdeveloper.mpchartexample.RadarChartActivitry;onCreate(Bundle);[59, 60, 61, 62];[72];Left, in the animateXY method, writes to the mAnimator attribute,;Right writes to XAxis.xCustomAxisMin. Below this, there are only getters and setters.;No;False;LEFT modifies the animateXY call (animation parameters/easing) in onCreate, affecting only the chart’s startup animation. RIGHT changes a single configuration line later in onCreate (likely an axis/legend setting such as text size, axis min value, or legend position). These affect different state elements of mChart (animation vs. styling/positioning) and do not override or depend on each other. The merged result can preserve both behaviors without interference.
62;MPAndroidChart;9297923f09460d0484cd713b0abbeaea9b888ec0;com.xxmassdeveloper.mpchartexample.StackedBarActivityNegative;onCreate(Bundle);[64, 65];[];"On the left side, it altered mChart.getAxisRight().setDrawGridLines(false); and mChart.getAxisRight().setDrawZeroLine(true);.";Right side removed setStartAtZero() from the getAxisRight object. This was probably due to the invalidate() method causing globally observable interference. However, as our focus is on LOI (Local Observability Interference), we should pay attention to these modifications.;No;False;"LEFT modified the chart’s right-axis rendering options around lines 64–65 (grid lines and zero line visibility), affecting only visual appearance. RIGHT made no changes. With no overlapping or interacting edits, the merged result preserves LEFT’s behavior and base behavior elsewhere; thus no semantic conflict."
63;MPAndroidChart;9297923f09460d0484cd713b0abbeaea9b888ec0;com.xxmassdeveloper.mpchartexample.LineChartActivity1;onCreate(Bundle);[135];[];"On the left side, it altered mChart.getAxisRight().setDrawZeroLine(true);.";On the right side, it removed setStartAtZero() from the getAxisRight object, but it was in a different class from the previous one. This was probably done to avoid globally observable interference caused by invalidate(). However, since our focus is on LOI (Local Observability Interference), we should closely examine these modifications.;No;False;"Only LEFT modified a single line in onCreate(Bundle) (line 135); RIGHT made no changes in this method. With no overlapping or related changes, the merge preserves LEFT’s behavior and the base behavior elsewhere. There is no state whose computed value would differ between L, R, and the merge, so no semantic conflict arises."
64;MPAndroidChart;9531ba69895cd64fce48038ffd8df2543eeea1d2;com.github.mikephil.charting.renderer.LineChartRenderer;drawData(Canvas);[];[];On the left side, two conditions were added: (mPathBitmap.getWidth() != mViewPortHandler.getChartWidth()) || (mPathBitmap.getHeight() != mViewPortHandler.getChartHeight()).;On the right side, the last condition was added, and it involved casting to an integer: (int) mViewPortHandler.getChartHeight().;Yes;False;"Neither LEFT nor RIGHT modified drawData(Canvas); thus, the merged version preserves the base behavior of this method and no state computations diverge."
65;MPAndroidChart;9531ba69895cd64fce48038ffd8df2543eeea1d2;com.github.mikephil.charting.renderer.PieChartRenderer;drawData(Canvas);[];[94];On the left side, two conditions were added: (mPathBitmap.getWidth() != mViewPortHandler.getChartWidth()) || (mPathBitmap.getHeight() != mViewPortHandler.getChartHeight()).;On the right side, the last condition was added, and it involved casting to an integer: (int) mViewPortHandler.getChartHeight().;Yes;False;"Left made no changes. Right modified a single line in drawData(Canvas), likely the canvas argument passed to drawDataSet (e.g., c -> mBitmapCanvas) or the bitmap clearing call. Since drawDataSet internally draws to mBitmapCanvas regardless, this change does not alter behavior. The merged program preserves both base and Right behavior; no state element is computed differently across B, L, R, and Merge."
66;netty;193acdb36cd3da9bfc62dd69c4208dff3f0a2b1b;org.jboss.netty.handler.codec.frame.LengthFieldBasedFrameDecoder;decode(ChannelHandlerContext, Channel, ChannelBuffer);[358, 360];[322, 374];Left updates how variable frameLength is incremented, which is done only if the new conditional in the if statement is true.;Right updates method call failIfNecessary adding a new parameter (boolean value). [But these changes were also done by Left.];Yes;False;RIGHT adjusts the core frame-length calculation and validation (notably handling of lengthFieldIncludedInFrameLength/lengthAdjustment and too-long frame behavior) across a larger block of decode(). LEFT touches only the final extraction/readerIndex-advance lines, likely switching to a simpler skip/extract pattern without changing which bytes constitute the frame. These changes are orthogonal: RIGHT determines the frameLength, LEFT changes how the already-determined bytes are consumed. The merged behavior preserves both the corrected length computation and the frame extraction semantics, so there is no semantic interference.
67;okhttp;35166168529bd27281685e56a0a122eff44460e9;com.squareup.okhttp.OkHttpClient;copyWithDefaults();[277, 293];[287];Left changed the object returned by the method using the current object of the class and ass a new value to the field transports.;Right changes the value assigned to result.hostnameverifier adding now an object OkHostnameVerifier.;No;False;"Left adjusted defaults in copyWithDefaults (two lines within the method), e.g., ensuring client fields fall back to expected system or OkHttp defaults; Right modified a single line in the same method (likely switching the default HostnameVerifier to a specific OkHostnameVerifier instance). These changes are complementary/refactor-like and yield the same effective values for the client’s state (no loss of Left/Right or base behavior). Hence, no semantic conflict."
68;okhttp;1151c9853ccc3c9c3211c613b9b845b925f8c6a6;com.squareup.okhttp.internal.bytes.GzipSource;consumeHeader(Deadline);[112];[138];Left does a refactoring by renaming the method getByte on OkBuffer class.;Right does a refactoring by extracting the local method seek to OkBuffers class.;No;False;Left modified logic earlier in consumeHeader (around optional header parsing/flags handling), while Right modified logic later in the method (around FHCRC verification). These changes affect different stages of header processing and do not alter the same state in conflicting ways. When merged, header fields are still parsed before any optional FHCRC validation is performed, preserving both behaviors and the base behavior.
69;OpenTripPlanner;4c506dce43775704919d084f0acfba86d251bf4a;org.opentripplanner.routing.spt.MultiShortestPathTree;dominates(State, State);[144, 146, 147, 148, 149, 152, 141];[123];Left renames some local variables and updates three boolean local variables used to define the method return.;Right adds a new if statement, which may return false.;Yes;False;"LEFT modifies the dominance heuristics near the end of the method (walk/weight/time hopeful checks and/or their thresholds), while RIGHT changes an early one-line condition (around the bike/car/bike-parked/related guard). These edits are in disjoint parts of dominates(State, State). In the merged code, the early guard from RIGHT is evaluated before the later heuristic logic from LEFT, so both behaviors are preserved. There is no state where the merge would revert either side’s change relative to its base; thus no semantic interference."
70;orientdb;a5ce3bcc0a1d196745c575ad6602019f7a6b86f8;com.orientechnologies.orient.core.Orient;startup();[191];[158];Left removes an IF statement and a method call on profiler field, and changes the location of an assignment for field active.;Right change the location of the profiler field instatiation.;No;False;Left modified a later part of startup() (around engine registration/config dump area), while Right modified an earlier part (ThreadPoolExecutor setup around cores/queue). These touch distinct concerns (engine availability vs. worker pool configuration). The merged result preserves both behaviors and no shared state is computed inconsistently, so there is no semantic conflict.
71;pushy;58901c846e4f0874977c5aabbc34bcb4de3670e0;com.relayrides.pushy.apns.PushManager;handleConnectionFailure(ApnsConnection<T>, Throwable);[481, 482, 483, 484, 485, 476, 478];[490];Left added a local variable called pushManager and created a for loop to iterate over a list of FailedConnectionListener.;"The right developer performed an ""extract method,"" which is a structural refactoring for the method startNewConnection().";No;False;Left changes adjust the failure handler’s connection management (e.g., ensuring bookkeeping like decrementing the unfinished-connection counter on failure and keeping listener notification async). Right changes tweak a single line in the same method, likely refining the condition for starting a replacement connection (e.g., only retrying when appropriate). These behaviors are complementary: notifying listeners, fixing the connection counter on failure, and conditionally starting a new connection can all coexist without altering each other’s intended effects or the base’s unchanged behavior.
72;pushy;58901c846e4f0874977c5aabbc34bcb4de3670e0;com.relayrides.pushy.apns.PushManager;handleConnectionClosure(ApnsConnection<T>);[520, 510];[515, 500, 502, 503];Left replaces “new Thread” with “listenerExecutor”;"Right does a refactoring by “extracting"" two local methods.";No;False;Left and Right both adjust ancillary behavior around connection closure without changing the core sequence: remove the connection, optionally start a replacement if not shut down, interrupt the dispatch thread, and decrement the unfinished-connection counter only after pending I/O completes. Left’s change tightens the dispatch thread interruption (e.g., adding an isAlive check or similar guard). Right’s change tweaks the interruption/closure handling lines (e.g., minor condition/order or executor usage). Neither change alters the key state transitions (connectionPool membership, unfinishedConnectionCount updates, or shutdown semantics). The merged behavior preserves both sides’ intent, so there is no semantic conflict.
73;quickml;bae968d9a85c0501ba8842a6f88e7fc2c6b78693;quickdt.experiments.OutOfTimeCrossValidatorRunner;getRandomForestBuilder(int, int);[];[42, 43];Left deletes a method call, which set the field maxDepth.;Right renames a local variable RandomForestBuilder, and replaces the method return for that local variable. This variable has a different type related to the method return type on Base commit, but the interface is still the superclass.;No;False;"Left made no changes. Right modified lines 42–43 in getRandomForestBuilder (the TreeBuilder/RandomForestBuilder configuration). With no overlapping Left changes, the merged result preserves Right’s behavior and does not alter unchanged base behavior. No state element differs between B/L and the merge; thus no semantic conflict."
74;resty-gwt;867b917c43c32acbdcac55767e7f04334006c866;org.fusesource.restygwt.rebind.DirectRestServiceInterfaceClassCreator;getMethodCallback(JMethod);[83, 84, 85];[86, 87, 88, 89, 90, 91];changed if statement (condition, and block) on method getMethodCallback(JMethod);extracted variable refactoring and added if statement on method getMethodCallback(JMethod);Yes;False;LEFT modifies the primitive-return branch of getMethodCallback (lines 83–85), while RIGHT modifies the non-primitive/overlay branch (lines 86–91). These branches are mutually exclusive for any given method return type, so the integrated code preserves both behaviors without interference. No state element is computed differently in the merge than in L or R individually.
75;retrofit;2b6c719c6645f8e48dca6d0047c752069d321bc4;retrofit.RestAdapter;logAndReplaceResponse(String, Response, long);[438];[415];Left writes in log a single time, a whole string, while base writes part of this string in many log operations. So left is not a refactoring.;Rigth extracts a method but adds conditionals to handle the case when the fields are null. So right is not a refactoring either.;Yes;False;Both changes affect only logging within logAndReplaceResponse. RIGHT modifies the initial response log line (e.g., formatting/status/URL/time), while LEFT changes how the body is logged (e.g., charset/length handling). They touch different parts of the method and do not affect request/response processing or the returned Response object. Their behaviors can coexist without interfering, so there is no semantic conflict.
76;retrofit;2b6c719c6645f8e48dca6d0047c752069d321bc4;retrofit.RestAdapter;logAndReplaceRequest(Request);[398];[369];Left writes in log a single time, a whole string, while base writes part of this string in many log operations. So left is not a refactoring.;Rigth extracts a method but adds conditionals to handle the case when the fields are null. So right is not a refactoring either.;Yes;False;Both changes affect only the logging behavior inside logAndReplaceRequest(Request) but in different subparts. The RIGHT change updates how request headers are logged (e.g., formatting/filtering during the header loop). The LEFT change updates the body logging/end-of-log details (e.g., handling charset/size or the END HTTP line) after the body may be buffered. These adjustments are independent: they do not alter request construction, execution, or response handling, and their effects on logging do not override each other. Thus, integrating them preserves both modified behaviors and the base behavior, yielding no semantic conflict.
77;retrofit;71f622ce51031b152a0be6ad5facfb27a654bf5a;retrofit.RequestBuilder;build();[88];[96, 97, 100, 95];"Left changed the argument of a method call and chained it with another call. Semantically, it inserts ""?"" in the middle of a string stored in the url variable.";Right adds an if statement that surrounds an assignment (which comes from base) to the url variable.;Yes;False;LEFT appears to change only the local headers list declaration/instantiation (a refactor with no behavioral impact). RIGHT changes build() to compute the body first and add a Content-Type header based on the body (and then pass the body to the Request). These are independent: LEFT’s refactor does not affect RIGHT’s header addition or body handling. The merged result preserves RIGHT’s new behavior and does not alter LEFT’s intent, so there is no semantic conflict.
78;RxJava;1c47b0cb26e6d971eefa42ebb3479099236b0125;rx.concurrency.TestScheduler;triggerActions(long);[100];[96, 97, 95];Left moves the value assignment of the field time from the first IF declaration to the end of the method declaration.;Right adds a new IF declaration. Now, an external method call is done only if current TimedAction object is not canceled.;No;False;"LEFT changes the per-step time update (e.g., to avoid moving the scheduler clock backwards when executing actions), while RIGHT restructures the loop condition/peek-remove pattern (e.g., combining the break condition or using poll). These touch different lines and concerns: LEFT affects how 'time' is updated for each executed action; RIGHT affects how due actions are dequeued. The integrated result preserves both behaviors: actions up to targetTime are executed in order, and the internal clock remains monotonic. No altered or base behavior is lost, so there is no semantic conflict."
79;RxJava;a40a4130edcdadc2340da5787ca30353018173f2;rx.internal.operators.OperatorMulticast;connect(Action1<?superSubscription>);[94];[128, 129, 131, 117, 118, 119, 120, 121, 122, 124, 125];Left modifies subscription.;Right modifies subject.;No;False;"LEFT makes a small, localized change in connect (single line) that does not alter the connection lifecycle or guarded state (likely a minor refactor such as using a different subscribe variant). RIGHT adjusts multiple lines in the latter part of connect, refactoring how waiting subscribers are attached and how the final subscription/unsubscription is performed, while preserving the guarded state transitions (subscription, guardedSubscription, connectedSubject). The changes affect different aspects and compose without altering each other's intended behavior; no shared state element ends up with a different value compared to either side alone."
80;SimianArmy;345ad9513aafff397050d613fa87ad06ddffe99d;com.netflix.simianarmy.basic.janitor.BasicJanitorMonkeyContext;getInstanceJanitor();[227, 228, 229, 230];[232, 233, 234, 235, 237, 238];Left updates the rule added in ruleEngine by method addRule().;Right adds a new if statement, which may also add a new rule in ruleEngine.;No;False;Left adds a new boolean configuration (opsworks.parentage) to OrphanedInstanceRule, altering how orphaned instances are detected. Right adds an UntaggedRule for instances to enforce required tags. These are independent additions to the rule set for InstanceJanitor and can coexist: the merged code preserves both behaviors (enhanced orphan detection and untagged enforcement). No state element is computed inconsistently between B, L, R, and Merge.
81;SimianArmy;c39c19bc6b9231601f6bc7358e638a99adf37e0d;com.netflix.simianarmy.basic.BasicSimianArmyContext;BasicSimianArmyContext(String);[128, 129, 130, 131, 115, 132, 133, 134, 135, 141, 126, 127];[112, 113, 114, 115, 110, 111];Left adds five new five fields on the class and their instantiations.;Right changes the contents that are written on the field LOGGER.;No;False;"LEFT adds AWS proxy/client configuration and passes ClientConfiguration to AWSClient and STSAssumeRoleSessionCredentialsProvider; RIGHT changes the property logging to avoid exposing secrets. These changes touch different concerns (runtime AWS client setup vs logging) and do not alter the same state semantics. The merged behavior preserves both: enhanced logging safety and optional proxy/assume-role support. No semantic interference."
82;spring-boot;958a0a45f164601d01cb706c19f22ed3e25eff56;org.springframework.boot.autoconfigure.mongo.MongoProperties;builder(MongoClientOptions);[272];[261, 262, 263, 264, 265, 266, 267, 268, 271];Left changes one attribute of an object using a set method;Left changes nine attributes of an object using a set method;No;False;"Left adjusts a single setter in the builder(MongoClientOptions) method (i.e., copies one additional/updated option from the given MongoClientOptions into the new Builder). Right updates several adjacent setters in the same block (e.g., adds/removes/adjusts multiple option copies such as replica set name, SSL, socket, threading, write concern). These changes are additive and affect only how options are transferred into the Builder; they do not change control flow or the decision of whether to use URI vs host/port. The modified line ranges do not overlap (Right: 261-268,271; Left: 272), so the merged version can include both sets of updates. Therefore, the integrated code preserves both sides’ intended behavior with no semantic interference."
83;spring-boot;af20dc6cc45c032573413c401f9f73aa75371744;org.springframework.boot.loader.archive.ExplodedArchiveTests;getUrl();[];[];Equals to the base class;Changed a test assert;No;False;Neither LEFT nor RIGHT modified ExplodedArchiveTests.getUrl() (or the class). With no changes, there is no interference and the behavior remains as in the base.
84;spring-boot;af20dc6cc45c032573413c401f9f73aa75371744;org.springframework.boot.loader.archive.ExplodedArchive;getUrl();[];[];Left removes one parameter (handler) for the new URL object, that is returned by the method.;Right updates one parameter used to create the URL object that is returned by the method, by calling toURL();No;False;Neither LEFT nor RIGHT modified ExplodedArchive.getUrl() (or the class). The merged result preserves the base behavior of returning this.root.toURI().toURL(). No state or behavior differences are introduced, so there is no semantic interference.
85;spring-boot;ea8107b6a53fa60b5f23b33e1b6d2e88bb60133c;org.springframework.boot.context.embedded.undertow.UndertowEmbeddedServletContainerFactory;createDeploymentManager(ServletContextInitializer);[357, 358, 359, 360, 345, 361, 362];[364];Left sets one attribute of object deployment, which is used to create the returned method object manager.;"Right modifies the way the returned manager object is created; before, it was done by calling the method defaultContainer from Servlets, and now it’s done by calling the method newContainer.";No;False;Left adjusts deployment setup (e.g., deployment name and surrounding initialization steps) and retains the session manager configuration flow. Right changes a single line to alter how the session timeout is applied (unit conversion). These changes affect different concerns and can coexist without altering each other’s intended behavior.
86;spring-boot;3444ebbc05b99a164474c14d6a6784f749514428;org.springframework.boot.context.web.SpringBootServletInitializer;createRootApplicationContext(ServletContext);[99];[121, 123];Modified a class's instance declaration, instead of using new Class(), called a method that does this.;Inserted a conditional (if) for an attribute that has not been changed from the left, checking if an attribute of the class is true or false.;No;False;LEFT adjusts the SpringApplicationBuilder configuration earlier in createRootApplicationContext (e.g., context class/builder setup), while RIGHT changes the error page filter registration near the end of the method. These affect independent concerns (context creation vs. error filter registration) and do not alter the same state, so the merged result preserves both behaviors without interference.
87;spring-boot;074771ec125dd407af0282b92960e9e9e3377e84;org.springframework.boot.context.web.SpringBootServletInitializer;createRootApplicationContext(ServletContext);[87];[88];extracts the instantiation of the object to another method;Change an object's attribute using a set method;No;False;Left modified the first part of the if-condition that checks whether application sources are empty, while Right modified the second part that checks for a configuration annotation on the class. These are independent operands of the same conditional (lines 87 and 88 respectively). When merged, both changes can coexist: the condition still evaluates as a conjunction of the updated emptiness check and the updated annotation check. No altered behavior from either side is lost, and no base behavior is broken, so there is no semantic conflict.
88;spring-boot;fdd3f12ee0f92ac18844c08bf71df39feebb6673;org.springframework.boot.autoconfigure.logging.AutoConfigurationReportLoggingInitializer;logAutoConfigurationReport(boolean);[114];[110];Change the string sent as a parameter to the logger.debug method;Change the string sent as a parameter to the logger.info method;Yes;False;Left changes the logging call/message in the crash-report branch (affecting only the emitted log text/format), while Right changes the condition that checks whether there are any outcomes (e.g., size() > 0 to !isEmpty), which is a behavior-preserving refactor. These modifications are orthogonal: one affects message content/format, the other the way emptiness is checked. The merged result can preserve both without altering the program’s behavior beyond the intended logging text change.
89;spring-boot;2d4e68a9777601bfb8309c94d8b74bc21be80ad1;org.springframework.boot.context.embedded.tomcat.TomcatEmbeddedServletContainerFactory;customizeConnector(Connector);[240, 241, 242, 243, 244, 246, 247, 248, 249];[228];Added an if condition that has an asset in its body. One method call to configureSsl and two set method calls to connector;Added a wildcard to the generic of the AbstractProtocol class which is used as a casting;No;False;LEFT modifies the connector’s later configuration (e.g., SSL setup, bindOnInit, scheme/secure, and running connector customizers), while RIGHT changes an earlier, separate line (likely address or URI encoding). These touch different aspects of Connector configuration and do not override each other. The merged result preserves both behaviors with no state element computed inconsistently.
90;storm;ad2be678831b3b060229fd936e3908110162b7ac;org.apache.storm.kafka.spout.KafkaSpout;open(Map, TopologyContext, SpoutOutputCollector);[];[118, 102];Left removes the assignment value to field maxRetries, which was also removed by Left.;Right assigns a value for field refreshSubscriptionTimer, which was also added by Right.;No;False;Left made no changes to the open method. Right changed two lines (likely timer/initialization details). Since only Right modified this area, the merge preserves Right’s behavior and does not interfere with Left or the base behavior. No state elements produce divergent values between B, L, R, and the Merge.
91;storm;ad2be678831b3b060229fd936e3908110162b7ac;org.apache.storm.kafka.spout.KafkaSpoutConfig;KafkaSpoutConfig(Builder<K,V>);[];[435, 436, 437, 438, 439, 440, 441, 430, 431];Left removes the assignment for field maxRetries, and also its declaration.;Right removes four fields and adds seven fields with their assignment.;No;False;LEFT made no changes. RIGHT modified the KafkaSpoutConfig(Builder<K,V>) area (e.g., assignments/initializations). With no competing edits from LEFT, the merge results in RIGHT’s behavior, so no interference or loss of behavior occurs.
92;storm;ad2be678831b3b060229fd936e3908110162b7ac;org.apache.storm.kafka.spout.KafkaSpoutConfig;toString();[];[515, 516, 521, 522];"Left removes the field and reference for maxRetries of the returning string from the method toString();";Right performs a refactoring involving the references for key and value variables. It updates how the variable values are accessed (now using get methods instead of directly accessing the values). Right also removes references to the field: kafkaSpoutStreams, tuplesBuilder, topics, and topicWildcardPattern. Finally, it adds reference for subscription and translator.;Yes;False;LEFT made no changes to toString(). RIGHT modified toString() (e.g., how deserializers are displayed or adding fields like partitionRefreshPeriodMs), affecting only the string representation. No overlapping edits or behavioral/state changes exist, so the merged result preserves RIGHT’s changes and LEFT’s no-op.
93;storm;bd1f5c54752f67b484a83c26667331234234d3a3;org.apache.storm.kafka.spout.KafkaSpout;emitTupleIfNotEmitted(ConsumerRecord<K,V>);[305, 306, 307, 312];[316, 319];"Left performs a refactoring extracting a variable of an IF statement; it also changes another IF condition.";Right updates the method signature changing its return type for boolean and adds return statements.;No;False;Left refines the skip logic around already-acked/emitted records (guarding acked lookups), while Right adjusts the emission path (e.g., only accounting/returning true when a tuple is actually emitted). These changes affect orthogonal concerns (dedup vs. emission/accounting) and compose without altering each other’s intended behavior or the base behavior.
94;swagger-core;e7fea7c4889dbdd6a4e0b2d059c8aa0f126ab1c2;io.swagger.jaxrs2.OperationParser;getSchemaFromAnnotation(io.swagger.oas.annotations.media.Schema);[240, 241, 234, 235, 236, 237, 238, 239];[244, 187, 188];Left adds two IF statements, which may set some fields on object schemaObject.;Right renames three methods _enum() to allowableValues(), and _default() to defaultValue;No;False;"LEFT fixes the maxLength/maxProperties handling in getSchemaFromAnnotation, likely setting the correct fields (and isEmpty) when these constraints are present. RIGHT adjusts other parts of the same method (e.g., around numeric bounds/other flags), likely marking the schema as non-empty when maximum/minimum or similar attributes are provided and possibly cleaning duplicate example handling. The changes target different attributes/conditions and are additive; the merged result preserves LEFT’s corrected handling of length/properties and RIGHT’s enhancements for other fields. No altered behavior from either side is lost, and unchanged base behavior is not broken."
95;titan;387c16ea05ef9fa312f37139228d2bbf61455ff4;com.thinkaurelius.titan.graphdb.database.serialize.SerializerInitialization;initialize(Serializer);[52, 53, 54, 55, 57];[31];Left adds and removes calls for method registerClass of serialize object, that registers new classes in the registrations hashmap.;Right changes one call for method registerClass by adding a new parameter (instead of only two), and this new parameter will be added into headers hashmap.;No;False;Left modifies registrations near the end: adds/adjusts serializers for Parameter, Parameter[], IndexParameters, IndexParameters[] and updates the ID-allocation precondition. Right changes the registration for byte[] at KRYO_OFFSET + 12 (likely serializer implementation). These affect different types/IDs and do not overlap or change KRYO_OFFSET. The merged result preserves both behaviors with unique IDs, so no semantic interference.
96;titan;04edd7f0e7eab2e8255a497922e34dc707d84c19;com.thinkaurelius.titan.graphdb.transaction.StandardTitanTx;StandardTitanTx(StandardTitanGraph, TransactionConfiguration, BackendTransaction);[182, 183];[197, 198, 199];Left created three private final type attributes and assigned two of them with a constructor within the method.;Right added a conditional and used other statements: config.getMetricsPrefix() and MetricManager.INSTANCE.getCounter(config.getMetricsPrefix());No;False;LEFT modifies early constructor initialization (likely the uniqueLocks/deletedRelations sentinel assignments). RIGHT changes later lines in the constructor (likely metrics/flag setup). They touch disjoint concerns and don’t change the logic relied on by the other side. The merged constructor preserves both behaviors without altering computed state values relative to LEFT or RIGHT, so there is no semantic interference.
97;voldemort;b30fdfebe30c9b6e37b9fbc3fec0ff74cd19f997;voldemort.VoldemortClientShell;VoldemortClientShell(ClientConfig, String, BufferedReader, PrintStream, PrintStream);[123];[128, 127];Left changed the parameters for the constructor of the adminClient object, inserting the reference passed by parameter instead of a new object.;Right created a local variable called 'cluster' that access the 'adminClient' attribute and assigned a 'RoutingStrategyFactory' object to routingStrategy, passing the created variable.;Yes;False;LEFT tweaks initialization in the constructor (e.g., obtaining admin client/store definition), while RIGHT adds initialization of routingStrategy by retrieving the cluster from adminClient and using storeDef. RIGHT’s new lines depend on objects initialized by LEFT but do not modify them. The merged code preserves LEFT’s behavior (admin client/storeDef setup) and adds RIGHT’s behavior (routing strategy setup for preflist) without changing existing semantics or shared state values.
98;voldemort;4cc1c145819030c8e2baffe4c92383de14b8d880;voldemort.server.VoldemortConfig;VoldemortConfig(Props);[359];[448, 455];Inserted a change to the readOnlyLoginIntervalMs attribute using the the object 'props' passed by parameter and the method getLong.;Inserted changes to the attributes nioConnectorKeepAlive and nioAdminConnectorKeepAlive, using the props object passed by parameter and the getBoolean methods and two different strings.;No;False;Left adjusts the server-routing configuration default (enable.server.routing) in the constructor, while Right changes client timeout initialization (using a long for the GET_VERSIONS timeout). These affect different configuration fields and code paths, so their behaviors do not interfere and are preserved when merged.
99;webbit;74d2d2b87704d003acacb34e4ca8fb5f897b938f;org.webbitserver.netty.WebSocketClient;adjustPipelineToWebSocket(ChannelHandlerContext, MessageEvent, ChannelHandler, ChannelHandler);[260];[262];Left sets the version of webSockectConnection object calling the method setHybiWebSocketVersion.;"Right changes the order of parameters used to create the local variable webSocketChannelHandler; so it's a refactoring.";No;False;Both changes adjust different steps in the pipeline switch-over after the WebSocket handshake. LEFT modifies the replacement related to the HTTP decoder, while RIGHT modifies a different pipeline element (e.g., encoder/handler) on another line. These are orthogonal updates to the same upgrade sequence and can coexist without altering each other's intended behavior. The merged pipeline still installs the WebSocket decoder, encoder, and handler correctly, preserving both sides' behavior and the base semantics.
