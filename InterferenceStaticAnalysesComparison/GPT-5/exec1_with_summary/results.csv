ID;project;merge commit;className;method;left modifications;right modifications;Summary of changes made by left;Summary of changes made by right;LOI;conflict;explanation
1;activiti;50d8e43eb5917c63abfbcdec1e68e510943f325a;org.activiti.engine.impl.persistence.entity.DeploymentEntityManager;deleteDeployment(String, boolean);[107];[114, 115, 116, 117];Left changes a if condition, that is reponsible for changing the value of the local variable nrOfProcessDefinitionsWithSameKey (incrementation);"Right adds a new IF statement; in case the condition is TRUE, it calls new mtethod using the objects of the local list timerStartJobs.";Yes;False;Left changes the condition that increments nrOfProcessDefinitionsWithSameKey, which only affects whether timer start jobs are deleted (the threshold check nrOfVersions - nrOfProcessDefinitionsWithSameKey <= 1). Right adds a new conditional block that invokes a new method using the existing timerStartJobs list. Right’s addition does not depend on or alter the count or its condition, and Left’s change does not affect the construction of timerStartJobs. In the merge, Left’s modified deletion decision is preserved and Right’s additional call can still execute as intended. No state element is computed inconsistently between L/R and the merge.
2;activiti;bf46684ba62f5883673ea8fb0a14aecfe0aedea2;org.activiti.engine.impl.bpmn.behavior.UserTaskActivityBehavior;execute(ActivityExecution);[112, 113, 114, 115, 116, 117, 110, 111];[118, 125, 126, 127];Left adds a new IF statement, which may set the field formKey of the local variable formKey, or throws an exception.;Right adds a new IF statement, which may call static external methods without using their returns.;Yes;False;"Left changes adjust the formKey handling to avoid an early cast and explicitly set the formKey only when the expression resolves to a String, otherwise throwing an ActivitiIllegalArgumentException. Right changes add a new conditional that invokes static methods with side effects and do not rely on or modify formKey. The areas of change do not overlap semantically: Left affects only task.formKey assignment and error handling; Right adds independent calls later. The merged result preserves Left’s behavior for formKey and includes Right’s additional side-effect calls. No state element gets a different value in Merge compared to L or R, and unchanged base behavior is preserved."
3;alluxio;dafe76c90024a915224264b4862b33f40cb8478c;tachyon.hadoop.HdfsFileInputStream;HdfsFileInputStream(TachyonFS, int, Path, Configuration, int);[44, 45];[52, 53, 56, 58];Changed the parameters of the debug method of the LOG attribute.;Renamed the variable mTachyonFile and changed it from local variable to class attribute.;No;False;Left only adjusts the LOG.debug call’s parameters in the constructor (logging change with no functional effect). Right promotes/renames the TachyonFile handle to a class field and uses it across methods, affecting state usage but independent of logging. The changes touch different concerns, do not compute different values for any shared state, and the merged result preserves both behaviors. Refactoring/renaming is non-conflicting per the criteria.
4;cloud-slang;20bac30d9bd76569aa6a4fa1e8261c1a9b5e6f76;io.cloudslang.lang.api.SlangImpl;getAllEventTypes();[116];[123, 124, 125];Left adds new values into a list;Right adds new values into a list;Yes;False;Both LEFT and RIGHT only add event types to the same returned Set in getAllEventTypes(). After merge, the set will contain the union of the new values, preserving each side’s added behavior and the base behavior. No state element is computed inconsistently, and duplicates are harmless in a Set.
5;cucumber-jvm;4505c156b6267c1b760deec570ddbfe047b42aa9;cuke4duke.internal.java.JavaLanguage;load(String);[38, 40];[36];Left adds a new IF statement, which may restrict the new addition of the local variable clazz on the field objectFactory.;Right changes generics allowing any type for the local variable clazz.;No;False;Left adds a runtime guard that further restricts when clazz is added to objectFactory (changing behavior by potentially adding fewer classes). Right only changes the generic type of clazz (e.g., to Class<?>), which is a compile-time typing change with no runtime effect. These changes affect different concerns and do not interfere: the merged code can keep the broader generics and the additional conditional, preserving both behaviors.
6;dropwizard;ddd15a681bf42360337844412cae4aba1556eb88;io.dropwizard.setup.Bootstrap;Bootstrap(Application<T>);[71];[65, 67, 68, 69];Left did a refactoring, an extract method, created a method that returns the 'metricRegistry' attribute.;Created an instance of the JmxReporter.Builder class and passed 'metricRegistry' as a parameter.;No;False;"Left only refactors access to metricRegistry via a getter; Right changes how the JmxReporter is instantiated (Builder) but still uses the same metricRegistry and starts it. Both changes preserve behavior: the same registry is used, the same JVM metrics are registered, and the JMX reporter is started. No state element computes a different value in B, L, R vs. the merge."
7;druid;05168808c278c080c59c19e858d9471b316cd1f5;com.metamx.druid.loading.S3SegmentPusher;push(File, DataSegment);[66, 118, 139, 110];[105, 125];Left changes the object that will be returned by setting the object field binaryVersion.;Right set the field acl on object toPush, which is used by the returned object.;No;False;"Left sets the DataSegment.binaryVersion on the returned segment; Right sets the ACL on the S3Object (toPush) used for uploading index.zip. These affect different state: binaryVersion of the returned DataSegment vs. ACL of the upload object. The loadSpec in the returned segment depends on toPush.getKey(), not its ACL, so Right’s change does not alter Left’s behavior. Both changes can coexist without altering each other or the base behavior."
8;elasticsearch;d896886973660785aac45275ddb110c1a6babc57;org.elasticsearch.action.index.TransportIndexAction;executeIndexRequestOnPrimary(IndexRequest, IndexShard, MappingUpdatedAction);[196];[201];"Added a call to a set method ""seqNo"", and passed the value as a parameter to the IndexResponse constructor";Extract variable on the object created by the IndexResponse constructor;No;False;LEFT adds setting the request’s seqNo from the operation and passes seqNo into the IndexResponse constructor, changing observable behavior to include sequence numbers and ensuring replication uses them. RIGHT only refactors by extracting the constructed IndexResponse into a variable, which does not change behavior. When merged, the seqNo behavior is preserved and the refactor remains non-functional, so there is no semantic conflict.
9;elasticsearch;d896886973660785aac45275ddb110c1a6babc57;org.elasticsearch.action.support.replication.ReplicationOperationTests;testReplication();[106, 108, 125, 126];[116, 103];Extracted a variable from constructor TestReplicationOperation creating a TestPrimary object (Refactor) and added two assertThat method calls on the end of the method;Changed the generic used at the PlainActionFuture type on the listener variable and Changed the type of shardInfo to import directly the inner ShartInfo, instead as accessing it from its outer class;No;False;"LEFT refactors by extracting the TestPrimary instance before constructing TestReplicationOperation and adds two final assertions verifying local checkpoints; these are behavioral no-ops (tests only) and do not alter execution. RIGHT adjusts the PlainActionFuture generic type and simplifies ShardInfo type usage via import; these are type-level/compile-time changes without runtime effect. The changes touch different concerns and do not alter or interfere with each other’s computed values or the base behavior, so there is no semantic merge conflict."
10;elasticsearch;d896886973660785aac45275ddb110c1a6babc57;org.elasticsearch.index.IndexSettings;IndexSettings(IndexMetaData, Settings, Predicate<String>, IndexScopedSettings);[238];[246, 269];Added the initialization to the globalCheckPointInterval field getting from scopedSettings map;Added the initialization to the maxRefreshListeners field getting from scopedSettings map and added a call to addSettingsUpdateConsumer for the key that got the maxRefreshListeners;No;False;"LEFT initializes the globalCheckpointInterval from scopedSettings; RIGHT initializes maxRefreshListeners from scopedSettings and registers a dynamic update consumer for it. These changes affect different settings and fields, do not overlap, and do not alter each other’s behavior. The merge preserves both behaviors without interference."
11;elasticsearch;d896886973660785aac45275ddb110c1a6babc57;org.elasticsearch.action.bulk.TransportShardBulkAction;update(IndexMetaData, BulkShardRequest, IndexShard, long[], VersionType[], Translog.Location, int, BulkItemRequest);[268, 255];[244, 249, 266, 254];Added the parameter seqNo to both calls of the UpdateResopnse constructor;Added a SupressWarning annotation twice and refactored the WriteResult class to return its parameters via getResponse and getLocation (Refactor);No;False;"LEFT adds the seqNo argument to UpdateResponse constructor calls in the update method (INDEX/UPSERT and DELETE cases), enriching the response. RIGHT adds @SuppressWarnings and refactors WriteResult usage to getters (getResponse/getLocation). The changes affect different concerns (response construction vs. accessors/annotations) and are compatible when merged. No altered behavior is lost and no shared state is computed differently; thus, no semantic conflict."
12;elasticsearch;d896886973660785aac45275ddb110c1a6babc57;org.elasticsearch.action.support.replication.TransportReplicationAction;doRun();[455, 458, 460];[457, 459];Left creates a new local variable, and assigns a value to it depending on a try, which was also changed by Left.;Right adds a new local variable and assings a value to it inside a try, which was chaged by Left.;Yes;False;Both sides add local variables around/in the same try-with-resources in doRun(), but these are independent, do not alter control flow, shared state, or the computed response. The method’s behavior—executing the replica operation, constructing the response, and replying—remains unchanged. Therefore, the integrated result preserves the behavior of Base, Left, and Right with no semantic interference.
13;elasticsearch;d896886973660785aac45275ddb110c1a6babc57;org.elasticsearch.action.support.replication.ReplicationOperation;execute();[98, 109];[113, 98, 99, 101, 119, 108, 110];Left creates a new local variable primaryRounting, while it also adds a new call for updateLocalCheckpointForShard on the field primary.;Right creates a new local variable primaryRounting and renames the local variable primaryId. It also adds a new call for replicaRequest on the field primaryResult.;No;False;"Left adds a call to update the primary’s local checkpoint after primary.perform(request) using the newly introduced primaryRouting; Right introduces the same local primaryRouting (and renames primaryId) and fetches the replicaRequest from primaryResult for replication. These changes are orthogonal and compatible—the merged code can both update the checkpoint and obtain/dispatch the replica request. No altered behavior is lost and no state is computed inconsistently."
14;elasticsearch;d896886973660785aac45275ddb110c1a6babc57;org.elasticsearch.index.engine.InternalEngineTests;testRecoverFromForeignTranslog();[2091];[2124];Left updates the method call for creating a new Index object. Now, it is also assigned a value for field seqNo.;Right updates the method call for creating a new EngineConfig object. Now, it is also assigned a value for field refreshListeners.;No;False;"Left adds a seqNo argument when constructing an Engine.Index operation; Right adds refreshListeners when constructing an EngineConfig. These changes touch different objects/parameters, occur on different lines, and are compatible API updates. The merged behavior preserves both the indexing behavior (seqNo handling) and engine configuration (refresh listeners), without altering test expectations."
15;elasticsearch;d896886973660785aac45275ddb110c1a6babc57;org.elasticsearch.index.engine.InternalEngine;InternalEngine(EngineConfig);[134];[161, 162, 163, 164];Left adds a new field in the class, and also assigns a value for it in the constructor.;Right adds a new IF statement, which whether a property on the object engineConfig is nulll.;No;False;"LEFT adds a new class field (e.g., openMode) and initializes it in the constructor; RIGHT adds a null-check on engineConfig (e.g., refresh listeners) and conditionally registers them. These changes affect different concerns and state: the new field assignment does not interact with the listener registration, and the null-check does not alter the semantics of the new field. Both behaviors can coexist without altering each other or the base behavior, so there is no semantic interference."
16;elasticsearch;d896886973660785aac45275ddb110c1a6babc57;org.elasticsearch.action.DocWriteResponse;writeTo(StreamOutput);[140];[141];Left adds a call for method writeZLong on the out object sending a long value.;Right adds a call for method writeBoolean on the object out sending a boolean value.;Yes;True;"Both changes independently extend the serialization in writeTo by appending new fields (LEFT adds a long via writeZLong; RIGHT adds a boolean via writeBoolean). The readFrom method is unchanged and does not consume these new fields. Merging both results writes both extra values, altering the wire format differently than either LEFT or RIGHT alone, and breaking the base’s unchanged behavior. Thus the integrated change does not preserve LEFT or RIGHT behavior and constitutes a semantic conflict."
17;elasticsearch;d896886973660785aac45275ddb110c1a6babc57;org.elasticsearch.action.DocWriteResponse;readFrom(StreamInput);[129];[130];Left adds a call for method readZLong on the in object.;Right adds a call for method readBoolean on the object in.;No;False;"Left adds reading a ZLong (seqNo) from the stream; Right adds reading a boolean (forcedRefresh). They target different fields and, when merged, are read sequentially after version. This matches the writeTo order (version -> seqNo -> forcedRefresh), so both behaviors are preserved and there is no semantic interference."
18;elasticsearch;d896886973660785aac45275ddb110c1a6babc57;org.elasticsearch.action.DocWriteResponse;toXContent(XContentBuilder, Params);[163, 164, 165, 166];[160];Left adds two calls for method field on the object builder.;Right adds a call for method field on the object builder.;Yes;False;"Both LEFT and RIGHT add new builder.field(...) calls in toXContent, which are additive to the serialized output. They do not modify or remove existing fields or logic, and there is no indication they target the same key. The merged result will include all added fields, preserving LEFT, RIGHT, and base behaviors; thus no semantic interference."
19;elasticsearch;d896886973660785aac45275ddb110c1a6babc57;org.elasticsearch.cluster.metadata.MetaDataCreateIndexService;createIndex(CreateIndexClusterStateUpdateRequest, ActionListener<ClusterStateUpdateResponse>);[315];[304, 305, 309, 310, 312, 346, 300];Left adds one new parameter when creating the local variable indexService.;Right extracts a local variable (refactoring) and also adds a new local variable routingNumShards.;No;False;Left only adds an extra argument to indicesService.createIndex when creating indexService. Right refactors by extracting locals (e.g., shrinkFromIndex) and introduces routingNumShards used to set routing shard count in temporary and final IndexMetaData builders. These changes are orthogonal: the additional parameter to createIndex does not alter or depend on the routingNumShards logic, and the refactoring preserves behavior. Therefore, integrating both preserves Left’s and Right’s intended behaviors with no semantic interference.
20;elasticsearch;d896886973660785aac45275ddb110c1a6babc57;org.elasticsearch.action.update.TransportUpdateAction;shardOperation(UpdateRequest, ActionListener<UpdateResponse>, int);[224, 185, 254];[192, 249, 250];Left adds new parameters when creating the local variable update.;Right sets the field forcedRefresh of the local variable update;No;False;Left modifies the UpdateResponse construction by adding new argument(s) (e.g., seqNo), while Right sets the forcedRefresh flag on the created UpdateResponse. These changes affect different fields, do not overwrite each other, and the merged code can preserve both behaviors (seqNo recorded and forcedRefresh propagated). Hence, no semantic interference.
21;elasticsearch;d896886973660785aac45275ddb110c1a6babc57;org.elasticsearch.action.delete.TransportDeleteAction;executeDeleteRequestOnPrimary(DeleteRequest, IndexShard);[136];[140];Left sets the field seqNo on object request, and added this value on the call to create the returned object DeleteResponse.;Right does a refactoring by extracting a variable, and them call the method to create the method return object.;No;False;Left adds semantic behavior: propagates seqNo to the request and includes it in the DeleteResponse. Right only refactors by extracting a variable and delegating creation of the return object without changing logic. These changes are orthogonal: the refactor does not alter computed values (version, seqNo, found, translog location), and the merge can preserve Left’s seqNo handling while keeping Right’s refactor. Therefore, no semantic interference.
22;elasticsearch;3764b3ff800c94293aba0bb0fa18c7df80a764f7;org.elasticsearch.rest.action.cat.RestNodesAction;getTableWithHeader(RestRequest);[];[153, 154, 156, 157, 158, 159];Removed calls to a method that modifies the table object;Changed parameters passed to a method that modifies the table object;No;False;LEFT removes some table-modifying calls (likely removing certain columns), while RIGHT adjusts the parameters of remaining table-modifying calls (changing aliases/descriptions). In the targeted method, LEFT did not modify these lines, and RIGHT’s updates simply change metadata for existing addCell calls. The merged behavior can preserve both: removed columns stay removed and updated parameters apply to retained columns. No semantic interference with state values or preserved behavior.
23;elasticsearch;3764b3ff800c94293aba0bb0fa18c7df80a764f7;org.elasticsearch.rest.action.cat.RestIndicesAction;getTableWithHeader(RestRequest);[];[144, 147, 150, 153, 138, 141];Removed calls to a method that modifies the table object;Changed parameters passed to a method that modifies the table object;No;True;Left removes certain table-modifying calls (e.g., header addCell calls) in getTableWithHeader, while Right changes the parameters passed to those same addCell calls (lines ~138–153). The state element is the Table’s header configuration. A merge cannot preserve both behaviors: either the calls are removed (losing Right’s parameter changes) or retained with modified parameters (violating Left’s removal). Hence, the integrated result fails to preserve one side’s altered behavior, indicating a semantic conflict.
24;elasticsearch;3764b3ff800c94293aba0bb0fa18c7df80a764f7;org.elasticsearch.rest.action.cat.RestShardsAction;getTableWithHeader(RestRequest);[];[112, 113];Removed calls to a method that modifies the table object;Changed parameters passed to a method that modifies the table object;No;True;Left removed certain table-modifying calls (e.g., addCell entries in getTableWithHeader), effectively removing some columns/headers from the cat shards output. Right changed the parameters of those same table-modifying calls (lines 112–113), altering header attributes for those columns. In any merged result, either the calls are kept (violating Left’s intent to remove them) or the calls remain removed (dropping Right’s parameter changes). Thus the state element (the Table’s header/schema) cannot preserve both changes simultaneously, indicating a semantic conflict.
25;elasticsearch;0404db65e3497452886173957729c8e82cfd4a03;org.elasticsearch.test.ESSingleNodeTestCase;newNode();[171];[173, 174];"Changed the key parameter passed 
to put, to a constant with the same value (Extract variable)";"Changed the key parameter passed 
to two other puts, to a constant with the same value (Extract variable)";No;False;Both LEFT and RIGHT replaced string literal keys in Settings.put(...) with equivalent constants (same string values). These are refactorings that do not alter runtime behavior. When merged, all keys still map to the same values, so no state or behavior changes, hence no semantic conflict.
26;elasticsearch;59cb67c7bd0ab6311115b20954e013412b676b29;org.elasticsearch.index.query.support.NestedInnerQueryParseSupport;setPathLevel();[193, 195, 197, 200];[199];"Left adds a new field, and use it to assign values for fields parentFilter and parentObjectMapper; it has the same behavior when compared to base commit.";Right changes the value assigned to childFilter;No;False;Left refactors how parentFilter and parentObjectMapper are set (using a new field) without changing behavior. Right changes the assignment of childFilter. These affect different state elements (parentFilter/parentObjectMapper vs childFilter) and are independent. The merged result preserves Left’s behavior for parent-related fields and Right’s new behavior for childFilter, so no semantic interference occurs.
27;elasticsearch;59cb67c7bd0ab6311115b20954e013412b676b29;org.elasticsearch.index.query.MultiMatchQueryBuilder;doXContent(XContentBuilder, Params);[306, 367];[];"Changed the parameter sent to the startObject method but the value of the parameter remained the same;

Removed two if conditions that made calls to the field method by passing (""boost"", boost) and (""_name"", queryName).

Added a call to the printBoostAndQueryName method passing the builder object as a parameter.";Removed an if condition (rewrite! = Null) that used the field method of the builder object;Yes;False;LEFT refactors the emission of boost and _name to a helper (no behavior change) and keeps the startObject name unchanged. RIGHT removes the emission of the rewrite parameter. These changes affect different output fields and do not override or depend on each other. The merged result preserves LEFT’s behavior (boost/_name printed via helper) and RIGHT’s change (rewrite omitted), so no semantic interference.
28;elasticsearch;f3d63095dbcc985e24162fbac4ee0d6914dc757d;org.elasticsearch.index.analysis.synonyms.SynonymsAnalysisTest;testSynonymsAnalysis();[65, 66, 67, 68, 69, 70, 71, 76];[73, 75];"Left extracts a local variable home of the parameter used on method put. Now, it's used the return of createTempDir instead of createTempDir().toString();";Right extracts a local variable json from the parameter sent to method loadFromStream. It also replaced the method call loadFromClasspath to loadFromStream, which is done by the method return object of settingsBuilder.;No;False;Left extracts a Path variable 'home' and passes it to settings (equivalent to the previous toString()), and uses it to create/copy config files. Right extracts a 'json' resource path and switches from loadFromClasspath to loadFromStream with the same resource. These are independent refactor-like changes affecting different parts (path.home setting vs settings loading) and preserve behavior. The merged code can include both without altering computed settings or test outcomes.
29;elasticsearch;f3d63095dbcc985e24162fbac4ee0d6914dc757d;org.elasticsearch.index.analysis.commongrams.CommonGramsTokenFilterFactoryTests;testQueryModeCommonGramsAnalysis();[229];[226, 228];Replaced the call to the createTempDir().toString() method with createHome();"Added a variable called Json containing a String with the path to the file commongrams_query_mode.json;
Replaced the loadFromClasspath method with loadFromStream;";No;False;"LEFT changes path.home to use createHome() so the test has a config/common_words.txt available; RIGHT refactors settings loading to use a json variable and loadFromStream. They touch different concerns (filesystem home vs. settings load mechanism). The merged result preserves both behaviors: settings are loaded from the resource stream and path.home points to a prepared home directory. No state element computed by L or R is altered incorrectly in the merge."
30;elasticsearch;f3d63095dbcc985e24162fbac4ee0d6914dc757d;org.elasticsearch.index.analysis.commongrams.CommonGramsTokenFilterFactoryTests;testCommonGramsAnalysis();[144];[141, 143];"Left changed the local settings variable with a call to put() method in settingsBuilder(), which uses the local variable called ""json"" changed by right.";Right changed the local variable json. Changed the local varibale called settings with a call to loadFromStream() method in settingsBuilder();No;False;"Right changes switch settings loading to loadFromStream using the json resource path; Left changes the settings builder to add/adjust a put call (path.home). These affect different settings keys and are complementary. The merged code loads the analyzer configuration from the JSON resource and sets path.home, preserving both changes’ intended behavior without altering base behavior elsewhere."
31;elasticsearch;f3d63095dbcc985e24162fbac4ee0d6914dc757d;org.elasticsearch.index.analysis.KuromojiAnalysisTests;createAnalysisService();[196, 197, 198, 199, 200, 201, 202, 206];[204, 207];"Left changed the local settings variable with a call to put() method in settingsBuilder(), which uses the local variable called ""json"" changed by right.
Changed other local variables: empty_dict, dict, home, config and Files, not used by right.";Right changed the local variable json. Changed the local varibale called settings with a call to loadFromStream() method in settingsBuilder();No;False;Right changes the JSON resource identifier and continues to load settings via loadFromStream(json, ...). Left adjusts filesystem setup and adds/changes a put(...) call that references the same json variable but does not remove or override the loadFromStream usage. The resulting Settings still set path.home, load the analysis config from the JSON stream, and set the index version. There is no state where L or R’s intended behavior is lost in the merge, so no semantic interference.
32;elasticsearch;36884807b3cc9d660db4da062275c7fdbec8ba67;org.elasticsearch.index.query.SimpleIndexQueryParserTests;setup();[217];[208];Left set the fields type and id on the local variable doc. Refactoring;Right adds a new entry on the local obecjt settings.;No;False;"Left refactors by explicitly setting type and id on the local ParsedDocument doc; Right adds a new key to the Settings builder. They modify different local state (doc vs settings) and do not affect each other’s behavior or the base behavior, so no semantic interference."
33;elasticsearch-river-mongodb;3d4f99516ba3177f7d88a1f600923138a8b77cc8;org.elasticsearch.river.mongodb.Slurper;assignCollections();[288, 289, 290, 322, 291, 292, 293, 294, 295, 297, 298, 286, 287];[315, 331, 302];Left adds some if statements and changed the values of two variables: adminDb and oplogDb.;Right changes the value of oplogRefsCollection by calling a method of oplogDb;Yes;False;Left adds conditional selection of adminDb and oplogDb based on configured auth databases, but ultimately ensures oplogDb points to the local database (where the oplog lives) after authentication. Right changes oplogRefsCollection to be obtained from oplogDb. These changes are complementary: using oplogDb for refs relies on Left’s correct setup of oplogDb. Default behavior is preserved when no custom auth DBs are provided, and custom auth DBs work as intended. No altered behavior is lost, so there is no semantic conflict.
34;elasticsearch-river-mongodb;6b6ce8e851c6613213c4508c3f277a80649e0c7b;org.elasticsearch.river.mongodb.MongoDBRiverDefinition;parseSettings(String, String, RiverSettings, ScriptService);[534, 646, 535, 536, 538, 539, 540, 541, 526];[561, 500, 567, 602, 475, 620, 655];Left changes the parameter used to assgin a value to field socketTimeout on local variable builder, sets the field isMongos on builder, and adds a new parameter used to instantiate the local variable scriptExecutable.;Right replaces the method calls of logger.info to logger.trace, and logger.warn to logger.error.;No;False;Left adds functional behavior: parses and sets isMongos, fixes the socketTimeout setting source, and updates scriptService.executable with an extra parameter. Right only changes logging levels (info->trace, warn->error), which does not affect program state. The merged result preserves Left’s functional changes and Right’s logging changes without altering computed state values.
35;elasticsearch-river-mongodb;3d4f99516ba3177f7d88a1f600923138a8b77cc8;org.elasticsearch.river.mongodb.MongoDBRiverDefinition;parseSettings(String, String, RiverSettings, ScriptService);[714, 699, 683, 717, 686, 703];[576, 515, 582, 617, 490, 635, 670];Left sets two fields on local variable builder.;Right replaces the method calls of logger.debug to logger.trace, and logger.warn to logger.error.;No;False;Left adds assignments to two builder fields in parseSettings, affecting configuration state. Right only changes log levels (debug->trace, warn->error). These changes touch different concerns and do not alter or interfere with computed program state. The merged result preserves Left’s builder values and Right’s logging behavior, so there is no semantic conflict.
36;elasticsearch-river-mongodb;6b6ce8e851c6613213c4508c3f277a80649e0c7b;org.elasticsearch.river.mongodb.Indexer;applyAdvancedTransformation(QueueEntry, String);[321];[288, 358, 331, 287];Left adds a new parameter used to instantiate the local variable scriptExecutable.;Right changes a IF verification and replaces method calls of logger.debug for logger.trace;No;False;Left changes only add an extra argument when creating the ExecutableScript (affecting the script’s execution context) and possibly rename the local variable. Right changes only adjust logging levels (debug->trace) and a benign IF condition check. These are orthogonal: logging and the minor condition tweak do not affect the script instantiation or data processing logic. The merged code preserves both behaviors without changing computed state (e.g., ctx/documents, operation, id, routing/parent).
37;elasticsearch-river-mongodb;6b6ce8e851c6613213c4508c3f277a80649e0c7b;org.elasticsearch.river.mongodb.Indexer;processBlockingQueue(QueueEntry);[176];[161, 198, 201, 189];Left adds a new parameter on constructor to instatiate the local variable executableScript.;Right replaces some method calls of logger.debug to logger.trace, and also removes an old call to write on logger (logger.debug). It assigns a hashmap object to local variable ctx.;No;False;"Left adds a parameter to scriptService.executable to pass a logger into the script; Right changes logging levels and initializes ctx as a new HashMap. These changes affect different concerns (script initialization vs. logging) and do not alter the computed state (operation, index/type, routing, parent, id, data). Both can coexist without altering each other’s behavior; the merged code preserves Left’s new script parameter and Right’s logging/ctx initialization."
38;elasticsearch-river-mongodb;6b6ce8e851c6613213c4508c3f277a80649e0c7b;org.elasticsearch.river.mongodb.Slurper;run();[105];[145, 148];Left adds a new IF statement, which could restrict the assginment value for the local variable startTimestamp.;Right replaces the method calls of logger.warn for logger.error;No;False;Left adds a conditional that restricts when startTimestamp is assigned during initial import, affecting the starting point for oplog slurping. Right only changes logging severity (warn -> error) in exception handlers. These modifications touch different concerns (state vs. logging), do not compute or depend on the same state elements, and their integration preserves both behaviors. Therefore, there is no semantic merge conflict.
39;elasticsearch-river-mongodb;6b6ce8e851c6613213c4508c3f277a80649e0c7b;org.elasticsearch.river.mongodb.Slurper;addToStream(Operation, Timestamp<?>, DBObject, String);[752, 747, 748, 751];[736, 737, 738, 739, 740, 741, 742, 743];Left adds new calls for writing on logger (logger.info).;Right adds a new call for writing on logger.;Yes;False;Both LEFT and RIGHT only add logging statements inside addToStream. They do not alter control flow, data enqueued to the stream, timestamps, operation types, or any stateful variables. As such, the integrated behavior of the program (outside of logs) remains the same, so there is no semantic merge conflict.
40;fitnesse;4d9ba9d221d879507440feb084fa7521b95111ec;fitnesse.testsystems.slim.tables.SlimTableFactory;SlimTableFactory();[24, 25];[31];Left adds two new elements into a map, by calling the add method addTableTye twice.;Right adds a new element into a map, also calling the method addTableType.;Yes;False;"Both changes add new table type mappings via addTableType in the constructor. These are additive to the tableTypes map and, assuming distinct keys (names/prefixes), they do not alter existing behavior or each other's behavior. The code guards against duplicate keys by throwing an exception; there is no indication that both sides added the same key, so the merge preserves all behaviors without interference."
41;fitnesse;4d9ba9d221d879507440feb084fa7521b95111ec;fitnesse.testsystems.slim.tables.SlimTableFactoryTest;setUp();[32, 31];[38];Left adds two entries on the field map.;Right adds one entry on the field map.;Yes;False;"Both sides only add new key→class mappings to the test map in setUp(). The map is used to iterate and assert correct table creation; adding entries is additive and independent. There’s no evidence of the same key being mapped to different classes, so the merged result simply includes all added entries and preserves behavior."
42;hector;0588608e7a2bdf974c985ff546207104f672bf6c;me.prettyprint.cassandra.connection.client.HSaslThriftClient;open();[96, 97, 94, 111, 95];[122];Left changed the local variable 'socket', inserting a try catch and changed the transport attribute.;Right changed the 'transport' variable and used it as a parameter for a method.;No;False;"Left refactors socket creation (adds try/catch, supports SSL) and assigns the opened Kerberos transport to the instance field 'transport'. Right uses 'transport' as an argument to another method (likely wrapping/initializing protocol). These changes are orthogonal: Left ensures 'transport' is properly created; Right consumes it. No shared state computes different values, and the merged behavior preserves both sides’ intents."
43;hector;a33a46506656a39d1b0f7780973905665d3b6145;me.prettyprint.cassandra.connection.client.HKerberosThriftClient;open();[88];[69, 70, 71, 72, 73, 74, 75, 76];Left changed the transport statement using the socket variable (changed by right).;Right added a try catch to check if 'param' was null, changing the socket statement.;No;False;"Right adds SSL-aware socket creation with a try/catch; Left changes the transport initialization to use the socket variable. These are complementary: the merged code wraps whatever socket Right created (plain or SSL) and preserves Left’s transport behavior. Keepalive and Kerberos steps still operate on socket.getSocket(). No altered or unchanged behavior is lost."
44;hector;213f7887ea70eabdf0705cf8454de29af89e8c38;me.prettyprint.cassandra.connection.HConnectionManager;operateWithFailover(Operation<?>);[267, 268];[200];Left changed the log level from log.error() to log.warn().;Right changed the creation of a local variable called 'stopWatch', changed the creation of a new instance with 'new', calling a method that returns an existing instance (stopWatchFactory.getStopWatch()).;No;False;"Left only changes logging severity (error -> warn) in the catch path; Right changes how the StopWatch is obtained (from new to StopWatchFactory). These affect different concerns (logging level vs. performance timing acquisition) and do not alter shared state or control flow. The merged result preserves both behaviors without interference."
45;hector;a33a46506656a39d1b0f7780973905665d3b6145;me.prettyprint.cassandra.connection.client.HThriftClient;open();[164];[147, 148, 149, 150, 151, 152, 169, 153, 154];Left changed the transport statement using the socket variable (changed by right).;Right added a try catch to check if 'param' was null, changing the socket statement. And added a condition to check that the 'transport' attribute was not open (! Transport.isOpen ()).;No;False;Right introduces the socket variable (with SSL-aware creation and a try/catch) and adds an isOpen guard before opening the transport. Left only changes the transport initialization to use that socket variable. These changes are complementary: Left’s refactor relies on the socket created by Right, and Right’s isOpen check still applies. The merged code preserves Right’s new behavior (proper socket creation and avoiding double-open) and Left’s refactor without altering base behavior elsewhere, so there is no semantic interference.
46;HikariCP;1bca94af9ec625f21d1b58ff10efb5be71ab87a6;com.zaxxer.hikari.HikariPool;addConnection();[356, 372, 374, 365];[339, 340, 341, 342, 343, 344, 345, 362, 346, 348];Left adds a new verification an an IF condition, does a refactoring for an old IF, and also adds a call for a local method.;Rights changes the assigment to local variable retries, adds some new IF statements, and sets the field loginTimeout on datasource.;Yes;True;Right redefines the meaning of the local variable 'retries' (from holding the configured acquireRetries to acting as a retry counter starting at 0) and adds loginTimeout handling. Left refactors/extends an IF that uses 'retries' (e.g., the speculative increment/maximumPoolSize guard) and adds a local method call. When merged, the IF conditions that depend on 'retries == 0' will now test the first attempt rather than 'no retries configured', altering when the pool-size guard and totalConnections accounting occur. This changes Left’s intended behavior or base behavior and interferes with Right’s retry logic, creating a semantic conflict. The added local method call itself is non-conflicting.
47;HikariCP;1bca94af9ec625f21d1b58ff10efb5be71ab87a6;com.zaxxer.hikari.HikariConfig;validate();[577, 578, 579, 580, 581, 582];[];Left adds a new IF statement, which may write in logger calling method info;Right removes source code, which would write in logger calling method error or wanr, or even trhows an exception. Changes on formating;Yes;False;"Left adds a new conditional that only emits an info log around the jdbcUrl handling; it does not change any state or control flow. Right removes some logging (warn/error) and some exception throws elsewhere in validate(), mostly affecting messages/validation strictness and formatting. The edits do not target the same stateful computations (e.g., dataSource assignment, timeouts, pool sizes) and do not alter each other’s effects. No shared state variable is computed differently due to the combination, so there is no semantic merge conflict."
48;java-faker;ca42fcfaf45cae1754c58e02e1d5d2a58ec03561;com.github.javafaker.Faker;Faker(Locale, Random);[69, 59];[70];Left adds an initialization of two fields on constructor.;Right changes the initialization of a different field.;No;False;Left adds constructor initialization for two fields, while Right changes the initialization of a different field. These changes affect distinct fields and can be combined in the merged constructor without overriding each other. No shared state is altered in a contradictory way, so the merged behavior preserves both Left’s added initializations and Right’s modified field initialization.
49;jenkins;48b2b951dfb3438999ceda330093cac82b857ce6;jenkins.slaves.DefaultJnlpSlaveReceiver;handle(String, JnlpSlaveHandshake);[52];[52, 56, 57];Left changed the return of a condition from false to true.;Right added an IF, checking if !MatchesSecret (nodeName, handshake) is true, changing the error message of the handshake attribute and error method, then returning true.;Yes;False;Left flips a return value for one condition, while Right adds a new secret-check branch (with its own error message and return). These affect different execution paths, so the merged code can preserve both: Right’s new matchesSecret check and Left’s changed return in its condition. No state element is computed to conflicting values by L and R for the same inputs.
50;jsoup;fee4762322f85a1109edd75ccb67f38cf5008c80;org.jsoup.helper.HttpConnection;createConnection(Connection.Request);[609, 610, 611, 612, 613, 614];[617];Left adds a IF statement, allowing extra set fields of the object returned by the method;Rights changes a IF condition, setting more fields of the object returned by the method and accepting more values than before;No;False;"Left adds a new conditional block in createConnection to set additional properties on the HttpURLConnection; Right relaxes a different conditional so another property is set in more cases. They touch different conditionals/fields within the same method and can be applied together without overriding or negating each other’s effects. No shared state is set to conflicting values, so the integrated result preserves both changes’ behaviors."
51;jsoup;a8b6982de98ff76ef254031d7152fff57f6bf941;org.jsoup.helper.HttpConnection;execute(Connection.Request, Response);[584, 585, 586];[544, 547];Left changes the value assigned to the local variable bodyStream, and also removes the local variable dataStream. The object bodyStream uses the object conn, that is created based on req (changed by Right).;Right adds a new verification before calling some methods of the parameter req.;Yes;False;"Right adds a precondition check on req (e.g., ensuring req.url() is non-null) before using it, affecting only error cases. Left refactors response-body reading by changing how bodyStream is obtained and removing dataStream, which is local to reading the response after the connection is created. These changes touch different concerns (validation vs. stream handling) and do not alter the same state elements; the merged code preserves both behaviors."
52;jsoup;3f7d2c71dbbbb289c684f339874eed8ac2747fa0;org.jsoup.helper.HttpConnection;execute(Connection.Request, Response);[456];[483, 484, 485];Left adds a new condition (OR) that is reponsible for changing the value of the local variable needsRedirect.;"Right updates another if statement conditions; it changes a set of conditions grouped with AND, to the OR operator. This if is responsible for throw a new exception.";Yes;False;Left adds an extra redirect condition, making needsRedirect true for an additional status code. Right changes the content-type validation to throw UnsupportedMimeTypeException under broader conditions (AND to OR). These changes affect different parts of the control flow: redirect handling is decided immediately after reading the status code and occurs before the content-type check. Thus, Left’s redirect behavior is preserved (it executes before content-type validation), and Right’s content-type exception behavior applies only when no redirect occurs. They do not alter the same state element or negate each other’s behavior.
53;jsoup;a44e18aa3c1fcd25a68a5965f9490d8f7d026509;org.jsoup.nodes.TextNode;outerHtmlHead(StringBuilder, int, Document.OutputSettings);[94];[98];"Left changes the condition of an if statement, which calls the method preserveWhitespace. Now the method only performs its verifications if the node is not null and is an instance of Element type; otherwise, no action is performed and the value of local variable html is not updated.";Right adds a new condition (OR) in an if statement, which may change the value of the parameter accum.;Yes;False;"LEFT refactors the pretty-print/whitespace-preservation guard to explicitly check parent non-null and Element before normalising html; this is semantically equivalent to the original short-circuited instanceof check, so html normalization behavior is unchanged. RIGHT broadens the condition that triggers indentation, affecting accum in more cases. The changes touch different conditions (normalization vs. indentation) and do not alter each other’s effects. The merge preserves RIGHT’s new indentation behavior and LEFT/base behavior for html normalization, so no semantic conflict."
54;libgdx;da27e2dae56be0a159e82231e5c3a5b83b099063;com.badlogic.gdx.backends.lwjgl3.Lwjgl3Application;newWindow(ApplicationListener, Lwjgl3WindowConfiguration);[318];[325];Left changes four attributes of an object using a set method;Right uses a set method to change the value of an object's attribute;No;False;"Left updates window size limit settings (four values) on the new window’s configuration, while Right updates a different single configuration attribute (e.g., visibility, decoration, listener, etc.). These settings are independent and applied before window creation. Integrating both preserves each change’s behavior and the base behavior; no state element is computed inconsistently in the merge."
55;libgdx;da27e2dae56be0a159e82231e5c3a5b83b099063;com.badlogic.gdx.backends.lwjgl3.Lwjgl3ApplicationConfiguration;copy(Lwjgl3ApplicationConfiguration);[96, 97, 98, 99];[107];Left assigns new values ​​from the method parameter to four different attributes of the object.;Right assigns a new value from the method parameter to an attribute of the object.;No;False;"Left updated the copy method to also copy four additional fields from the source config; Right updated it to copy one other field. These assignments are to distinct attributes and are independent, and assignment order does not affect semantics here. In the merge, all targeted fields can be copied, preserving both Left’s and Right’s intended behavior and the base behavior for other fields. Therefore, there is no semantic merge conflict."
56;logback;542843fd04a793fb9e0eea0c84d199e66d7c15af;ch.qos.logback.core.rolling.TimeBasedFileNamingAndTriggeringPolicyBase;start();[45];[52, 53, 54, 55, 56];Extracted a variable from constructor DateTokenConverter creating a Object object (Refactor) called dtc.;Created a condition with the dtc object, checking if getTimeZone is different from null and returning an instance of the RollingCalendar object.;Yes;False;Left only refactors by introducing a local variable (dtc) for the DateTokenConverter, with no behavioral change. Right uses dtc to create a timezone-aware RollingCalendar when a timezone is present. These changes compose cleanly: the merge preserves Right’s intended behavioral change and Left’s refactor. No state (e.g., rc, nextCheck) is computed differently in Merge versus Right, and Left’s behavior is preserved.
57;MPAndroidChart;af114d180da6ec5633d32c701ff5467f7629fcf3;com.xxmassdeveloper.mpchartexample.fragments.SimpleFragment;generateScatterData(int, float, int);[80, 91];[73];"Changes the values passed to the Entry class constructor, inverting the passed parameters, that changes inteferes with a call to setScatterShape modifying an attribute on the ScatterDataSet class . Removes the value ""ChartData.generateXVals(0, count)"" from the ScatterObject creation";"Changes the method that initializes the shapes array to ""ScatterChart.ScatterShape.getAllDefaultShapes()"" that adds new shapes to the shapes variable";No;False;LEFT adapts to the new data API by swapping Entry constructor args to (x=j, y=value) and using the ScatterData(sets) constructor (removing explicit xVals). RIGHT only changes the pool of shapes via getAllDefaultShapes(), affecting visual shape selection. These changes operate on independent concerns (data coordinates vs. shape selection) and do not compute the same state differently. The merged result can preserve both behaviors without interference.
58;MPAndroidChart;af114d180da6ec5633d32c701ff5467f7629fcf3;com.xxmassdeveloper.mpchartexample.ScatterChartActivity;onProgressChanged(SeekBar, int, boolean);[178, 168, 188, 204, 173, 205];[183, 186, 191];Left made changes to yVals1, yVals2, and yVals3, then also altered the same object set2 from right but in different attributes. Finally, left modifies the data object, which contains a list with set1, set2, and set3.;Right made changes to set1, set2, and set3, which were created using yVals but are elements of different states. Both sides preserved each other's changes.;No;False;Left changed the generated data lists (yVals1..3), adjusted some attributes of set2, and modified the ScatterData object. Right changed styling/attributes for set1, set2, and set3. These edits target different aspects (data content vs. rendering attributes, or different fields of set2) and were preserved together in the merge. No side’s behavior is overridden and the base behavior is maintained, so there is no semantic conflict.
59;MPAndroidChart;af114d180da6ec5633d32c701ff5467f7629fcf3;com.xxmassdeveloper.mpchartexample.ScatterChartActivity;onCreate(Bundle);[80, 86, 77, 63];[57];Left refactored by renaming tf to mtfLight and moved the variable initialization to the onCreate method of the superclass. And writes to maxHighlightDistance, and right writes to shapeRendererList.;Right writes to shapeRendererList.;No;False;"Left refactors the typeface field initialization to the superclass and sets maxHighlightDistance; Right adds a custom scatter shape renderer (writes to shapeRendererList). These changes affect different state elements (typeface/maxHighlightDistance vs. shapeRendererList) and can coexist without altering each other's behavior or the base behavior."
60;MPAndroidChart;9297923f09460d0484cd713b0abbeaea9b888ec0;com.xxmassdeveloper.mpchartexample.LineChartActivity2;onCreate(Bundle);[126];[117];Added a call to the setDrawZeroLine method setting the value for the field mDrawZeroLine at the rightAxis object as false.;Deprecated the method setStartAtZero from the YAxis class, and removed the call for it on the rightAxis object. Added a call to the method setAxisMinValue on the left axis object;No;False;LEFT explicitly disables drawing the zero line on the right Y axis (setDrawZeroLine(false)). RIGHT removes a deprecated setStartAtZero call and sets an explicit minimum on the left Y axis (setAxisMinValue). These changes affect different properties/axes and do not override each other. The merged code preserves RIGHT’s axis range behavior and LEFT’s zero-line setting (which matches the default), so no semantic interference occurs.
61;MPAndroidChart;9297923f09460d0484cd713b0abbeaea9b888ec0;com.xxmassdeveloper.mpchartexample.RadarChartActivitry;onCreate(Bundle);[59, 60, 61, 62];[72];Left, in the animateXY method, writes to the mAnimator attribute,;Right writes to XAxis.xCustomAxisMin. Below this, there are only getters and setters.;No;False;Left changes only affect animation (animateXY now writes to the chart’s mAnimator), while Right changes only affect axis configuration (sets XAxis.xCustomAxisMin). These touch disjoint state (animation vs axis settings) and do not alter the same behavior or rely on each other, so the merged program preserves both behaviors without interference.
62;MPAndroidChart;9297923f09460d0484cd713b0abbeaea9b888ec0;com.xxmassdeveloper.mpchartexample.StackedBarActivityNegative;onCreate(Bundle);[64, 65];[];"On the left side, it altered mChart.getAxisRight().setDrawGridLines(false); and mChart.getAxisRight().setDrawZeroLine(true);.";Right side removed setStartAtZero() from the getAxisRight object. This was probably due to the invalidate() method causing globally observable interference. However, as our focus is on LOI (Local Observability Interference), we should pay attention to these modifications.;No;False;"Left changes toggle grid lines and enable the zero line on the right axis; Right removes setStartAtZero() on the right axis. These affect different properties. Since the axis min/max are explicitly set to -25 and 25, startAtZero had no effect, so its removal does not interfere with the left changes or base behavior."
63;MPAndroidChart;9297923f09460d0484cd713b0abbeaea9b888ec0;com.xxmassdeveloper.mpchartexample.LineChartActivity1;onCreate(Bundle);[135];[];"On the left side, it altered mChart.getAxisRight().setDrawZeroLine(true);.";On the right side, it removed setStartAtZero() from the getAxisRight object, but it was in a different class from the previous one. This was probably done to avoid globally observable interference caused by invalidate(). However, since our focus is on LOI (Local Observability Interference), we should closely examine these modifications.;No;False;Left enables drawZeroLine on the chart’s right Y-axis in LineChartActivity1, but that axis remains disabled (setEnabled(false)) in the base, so the change has no visible effect. Right’s change removes setStartAtZero() in a different class and does not touch this method or chart instance. The merged program preserves base and left behaviors in this method, and there is no interfering state between the two changes.
64;MPAndroidChart;9531ba69895cd64fce48038ffd8df2543eeea1d2;com.github.mikephil.charting.renderer.LineChartRenderer;drawData(Canvas);[];[];On the left side, two conditions were added: (mPathBitmap.getWidth() != mViewPortHandler.getChartWidth()) || (mPathBitmap.getHeight() != mViewPortHandler.getChartHeight()).;On the right side, the last condition was added, and it involved casting to an integer: (int) mViewPortHandler.getChartHeight().;Yes;False;"Left added checks to recreate the path bitmap when its width/height differ from the chart’s dimensions; Right added an int cast to the height comparison to avoid float/int mismatch. The merged code compares both width and height against (int) chart dimensions, thus incorporating Left’s additional checks and Right’s casting fix. This preserves and improves intended behavior without interference."
65;MPAndroidChart;9531ba69895cd64fce48038ffd8df2543eeea1d2;com.github.mikephil.charting.renderer.PieChartRenderer;drawData(Canvas);[];[94];On the left side, two conditions were added: (mPathBitmap.getWidth() != mViewPortHandler.getChartWidth()) || (mPathBitmap.getHeight() != mViewPortHandler.getChartHeight()).;On the right side, the last condition was added, and it involved casting to an integer: (int) mViewPortHandler.getChartHeight().;Yes;False;"Left adds checks to recreate the cached bitmap when chart size changes; Right refines the comparison by casting chartHeight to int to avoid float–int mismatch. Combined, the code re-creates the bitmap on real size changes while preventing unnecessary re-allocations due to fractional floats. The behaviors are complementary and preserved; no interfering state or altered behavior is lost."
66;netty;193acdb36cd3da9bfc62dd69c4208dff3f0a2b1b;org.jboss.netty.handler.codec.frame.LengthFieldBasedFrameDecoder;decode(ChannelHandlerContext, Channel, ChannelBuffer);[358, 360];[322, 374];Left updates how variable frameLength is incremented, which is done only if the new conditional in the if statement is true.;Right updates method call failIfNecessary adding a new parameter (boolean value). [But these changes were also done by Left.];Yes;False;Left changes adjust the frameLength calculation logic (conditional increment), while Right changes refactor failIfNecessary to take a boolean and update its call sites. These edits are orthogonal: Right does not alter the frameLength computation, and Left also includes the updated failIfNecessary usage. The merged result preserves Left’s intended behavior for frame length handling and Right’s refactoring, so no semantic interference occurs.
67;okhttp;35166168529bd27281685e56a0a122eff44460e9;com.squareup.okhttp.OkHttpClient;copyWithDefaults();[277, 293];[287];Left changed the object returned by the method using the current object of the class and ass a new value to the field transports.;Right changes the value assigned to result.hostnameverifier adding now an object OkHostnameVerifier.;No;False;"Left changes use the copy constructor (sharing failedRoutes) and add a default for transports; Right changes the default hostnameVerifier to OkHostnameVerifier. These affect independent fields (failedRoutes/transports vs. hostnameVerifier). The merged method can contain both: new OkHttpClient(this), setting transports default, and using OkHostnameVerifier. No altered behavior is lost, so there is no semantic conflict."
68;okhttp;1151c9853ccc3c9c3211c613b9b845b925f8c6a6;com.squareup.okhttp.internal.bytes.GzipSource;consumeHeader(Deadline);[112];[138];Left does a refactoring by renaming the method getByte on OkBuffer class.;Right does a refactoring by extracting the local method seek to OkBuffers class.;No;False;Left refactors the call to OkBuffer.getByte (method rename), and Right refactors the zero-terminator search by calling OkBuffers.seek (method extraction). Both changes are behavior-preserving, affect different parts of consumeHeader, and do not alter computed values (flags byte read vs. name/comment scanning). No semantic interference arises.
69;OpenTripPlanner;4c506dce43775704919d084f0acfba86d251bf4a;org.opentripplanner.routing.spt.MultiShortestPathTree;dominates(State, State);[144, 146, 147, 148, 149, 152, 141];[123];Left renames some local variables and updates three boolean local variables used to define the method return.;Right adds a new if statement, which may return false.;Yes;False;"Right adds a new early-return condition (return false) near the start of dominates; Left only renames locals and adjusts the three boolean checks used in the final return. These changes affect disjoint parts of the method: if Right’s condition triggers, both R and Merge return false; otherwise, the final decision uses Left’s updated boolean logic. The merged result preserves both sides’ behaviors, so there is no semantic interference."
70;orientdb;a5ce3bcc0a1d196745c575ad6602019f7a6b86f8;com.orientechnologies.orient.core.Orient;startup();[191];[158];Left removes an IF statement and a method call on profiler field, and changes the location of an assignment for field active.;Right change the location of the profiler field instatiation.;No;False;Left removes a conditional and a profiler method call, and reorders the assignment to the 'active' flag. Right only reorders where the profiler instance is created. These changes are orthogonal: moving profiler instantiation does not depend on nor restore the removed profiler call, and Right does not touch the 'active' flag. In the merge, profiler remains uncalled as per Left, and 'active' assignment remains at Left’s new position. No state (profiler or active) computes a conflicting value compared to Left or Right intentions, so there is no semantic interference.
71;pushy;58901c846e4f0874977c5aabbc34bcb4de3670e0;com.relayrides.pushy.apns.PushManager;handleConnectionFailure(ApnsConnection<T>, Throwable);[481, 482, 483, 484, 485, 476, 478];[490];Left added a local variable called pushManager and created a for loop to iterate over a list of FailedConnectionListener.;"The right developer performed an ""extract method,"" which is a structural refactoring for the method startNewConnection().";No;False;"Left adds asynchronous notification of FailedConnectionListener on connection failure and then starts a replacement connection via startNewConnection(); Right performs an extract-method refactoring for startNewConnection() without changing behavior. These changes are orthogonal: listener notifications do not interfere with how a new connection is started, and the refactoring preserves the same startNewConnection() call site. The merged code preserves Left’s new behavior and Right’s refactoring, so no semantic interference occurs."
72;pushy;58901c846e4f0874977c5aabbc34bcb4de3670e0;com.relayrides.pushy.apns.PushManager;handleConnectionClosure(ApnsConnection<T>);[520, 510];[515, 500, 502, 503];Left replaces “new Thread” with “listenerExecutor”;"Right does a refactoring by “extracting"" two local methods.";No;False;"Left changes the closure-handling task from spawning a new Thread to submitting to the existing listenerExecutorService, affecting only execution context/scheduling. Right only refactors by extracting helper methods without changing behavior. When merged, the extracted methods can still submit the task to listenerExecutorService, preserving Left’s intended behavior and Right’s refactoring intent; no state values or outcomes differ beyond Left’s change."
73;quickml;bae968d9a85c0501ba8842a6f88e7fc2c6b78693;quickdt.experiments.OutOfTimeCrossValidatorRunner;getRandomForestBuilder(int, int);[];[42, 43];Left deletes a method call, which set the field maxDepth.;Right renames a local variable RandomForestBuilder, and replaces the method return for that local variable. This variable has a different type related to the method return type on Base commit, but the interface is still the superclass.;No;False;Left removes the maxDepth configuration on the TreeBuilder, changing model behavior (tree depth default). Right only refactors the local variable (name/type to the superclass) and return statement without affecting behavior. The merged result preserves Left’s behavioral change and Right’s refactoring, so there is no semantic interference.
74;resty-gwt;867b917c43c32acbdcac55767e7f04334006c866;org.fusesource.restygwt.rebind.DirectRestServiceInterfaceClassCreator;getMethodCallback(JMethod);[83, 84, 85];[86, 87, 88, 89, 90, 91];changed if statement (condition, and block) on method getMethodCallback(JMethod);extracted variable refactoring and added if statement on method getMethodCallback(JMethod);Yes;False;"Left modified the primitive-return case (the first if branch) in getMethodCallback, while Right refactored and added logic in the subsequent non-primitive branch (after computing the return type string/variable and handling overlay vs. method callbacks). These affect disjoint execution paths: if the return type is primitive, Left’s branch returns immediately and Right’s new logic is not reached; if it is non-primitive, Right’s logic applies and Left’s change is irrelevant. The merged result preserves Left’s intended behavior for primitives and Right’s intended behavior for non-primitives/overlays, so no altered or unchanged behavior is lost."
75;retrofit;2b6c719c6645f8e48dca6d0047c752069d321bc4;retrofit.RestAdapter;logAndReplaceResponse(String, Response, long);[438];[415];Left writes in log a single time, a whole string, while base writes part of this string in many log operations. So left is not a refactoring.;Rigth extracts a method but adds conditionals to handle the case when the fields are null. So right is not a refactoring either.;Yes;False;Left consolidates multiple log calls in logAndReplaceResponse into a single log call (same content, different batching). Right extracts helper logic and adds null checks to avoid NPEs when fields are null. These behaviors are orthogonal: the null-safety can be retained while still emitting a single aggregated log message. No response/request state or conversion behavior changes, so both changes can be combined without semantic interference.
76;retrofit;2b6c719c6645f8e48dca6d0047c752069d321bc4;retrofit.RestAdapter;logAndReplaceRequest(Request);[398];[369];Left writes in log a single time, a whole string, while base writes part of this string in many log operations. So left is not a refactoring.;Rigth extracts a method but adds conditionals to handle the case when the fields are null. So right is not a refactoring either.;Yes;True;Left rewrites logAndReplaceRequest to build and emit the request log in a single call, replacing the original step-by-step logging. Right extracts logic and adds null checks (e.g., for headers/body) to avoid NPEs. In the overlap, Left’s rewrite likely omits Right’s new conditionals. The merged code would then potentially throw (e.g., iterating/formatting null headers/body), whereas Right’s version would not, changing runtime behavior. Thus the integrated changes do not preserve Right’s altered behavior and introduce a semantic conflict.
77;retrofit;71f622ce51031b152a0be6ad5facfb27a654bf5a;retrofit.RequestBuilder;build();[88];[96, 97, 100, 95];"Left changed the argument of a method call and chained it with another call. Semantically, it inserts ""?"" in the middle of a string stored in the url variable.";Right adds an if statement that surrounds an assignment (which comes from base) to the url variable.;Yes;False;"Left modifies the URL construction to insert a '?' before appending the query portion; Right wraps the assignment/appending to the url in an if-guard. In the merge, the guarded assignment will still include Left’s inserted '?'. When the guard is false the code behaves like base (no change), and when true it behaves like Left. Thus, the final URL string is preserved in both cases and there is no semantic interference."
78;RxJava;1c47b0cb26e6d971eefa42ebb3479099236b0125;rx.concurrency.TestScheduler;triggerActions(long);[100];[96, 97, 95];Left moves the value assignment of the field time from the first IF declaration to the end of the method declaration.;Right adds a new IF declaration. Now, an external method call is done only if current TimedAction object is not canceled.;No;False;"Left ensures the scheduler’s time is set to targetTimeInNanos at the end of triggerActions, regardless of whether any actions ran. Right adds a guard to skip invoking the action if the TimedAction has been cancelled. These changes are orthogonal: Left affects only the final time update, while Right affects whether the action is executed. The merged code preserves both behaviors (time updated at the end; cancelled actions not executed), so there is no semantic interference."
79;RxJava;a40a4130edcdadc2340da5787ca30353018173f2;rx.internal.operators.OperatorMulticast;connect(Action1<?superSubscription>);[94];[128, 129, 131, 117, 118, 119, 120, 121, 122, 124, 125];Left modifies subscription.;Right modifies subject.;No;False;"Left changes the upstream Subscriber ('subscription') that forwards source events into the Subject (e.g., creation/management of the 'subscription' and unsubscription handling). Right changes how the Subject is used for downstream subscribers (e.g., how waiting subscribers are attached to the subject and/or how the subject is recorded in connectedSubject). These operate on different state elements: Left affects 'subscription' and its lifecycle; Right affects 'subject' usage for consumers. They don’t overwrite each other’s behavior or change the same state in incompatible ways. The merged code still routes source -> subscription -> subject and subscribes waiting observers to the subject, preserving both modifications’ intended behavior. Therefore, there is no semantic merge conflict."
80;SimianArmy;345ad9513aafff397050d613fa87ad06ddffe99d;com.netflix.simianarmy.basic.janitor.BasicJanitorMonkeyContext;getInstanceJanitor();[227, 228, 229, 230];[232, 233, 234, 235, 237, 238];Left updates the rule added in ruleEngine by method addRule().;Right adds a new if statement, which may also add a new rule in ruleEngine.;No;False;Left modifies the parameters/implementation of an existing rule added to the Instance janitor’s ruleEngine, while Right adds a new conditional that may register an additional rule. These are additive, independent changes to the rule set: the merge will contain the updated existing rule plus the newly added rule, preserving both behaviors and the base behavior. No semantic interference is expected.
81;SimianArmy;c39c19bc6b9231601f6bc7358e638a99adf37e0d;com.netflix.simianarmy.basic.BasicSimianArmyContext;BasicSimianArmyContext(String);[128, 129, 130, 131, 115, 132, 133, 134, 135, 141, 126, 127];[112, 113, 114, 115, 110, 111];Left adds five new five fields on the class and their instantiations.;Right changes the contents that are written on the field LOGGER.;No;False;"Left adds new fields and initializes them; Right changes log message content written via LOGGER. These touch different concerns: state/configuration vs. logging output. They do not alter the same state elements or behavior paths, and both changes can coexist without affecting each other’s semantics."
82;spring-boot;958a0a45f164601d01cb706c19f22ed3e25eff56;org.springframework.boot.autoconfigure.mongo.MongoProperties;builder(MongoClientOptions);[272];[261, 262, 263, 264, 265, 266, 267, 268, 271];Left changes one attribute of an object using a set method;Left changes nine attributes of an object using a set method;No;False;"Both sides modify the same builder(MongoClientOptions) method to set options on MongoClientOptions.Builder by copying values from the provided options. The LEFT change adds/adjusts one property; the RIGHT change adds/adjusts nine other properties. These are independent, additive setters and do not alter shared logic or each other’s values. The merged result will set all specified properties, preserving the behavior intended by both sides and the base."
83;spring-boot;af20dc6cc45c032573413c401f9f73aa75371744;org.springframework.boot.loader.archive.ExplodedArchiveTests;getUrl();[];[];Equals to the base class;Changed a test assert;No;False;LEFT makes no changes (same as base). RIGHT adjusts a test assertion (e.g., in getUrl()). Merging results in the RIGHT version of the test with no overlapping modifications or altered production logic. Therefore, no semantic interference occurs.
84;spring-boot;af20dc6cc45c032573413c401f9f73aa75371744;org.springframework.boot.loader.archive.ExplodedArchive;getUrl();[];[];Left removes one parameter (handler) for the new URL object, that is returned by the method.;Right updates one parameter used to create the URL object that is returned by the method, by calling toURL();No;False;"Left removes the custom handler from URL creation; Right changes the construction to use root.toURI().toURL(). Both aim to return a standard URL for the root directory without a handler. The merged result (using toURL() with no handler) preserves both changes’ intended behavior, so there’s no semantic interference."
85;spring-boot;ea8107b6a53fa60b5f23b33e1b6d2e88bb60133c;org.springframework.boot.context.embedded.undertow.UndertowEmbeddedServletContainerFactory;createDeploymentManager(ServletContextInitializer);[357, 358, 359, 360, 345, 361, 362];[364];Left sets one attribute of object deployment, which is used to create the returned method object manager.;"Right modifies the way the returned manager object is created; before, it was done by calling the method defaultContainer from Servlets, and now it’s done by calling the method newContainer.";No;False;Left adds a configuration attribute to DeploymentInfo before creating the DeploymentManager. Right changes the Undertow container creation from defaultContainer() to newContainer(). These changes affect different concerns (deployment configuration vs container instance creation) and are compatible. The merged code preserves Left’s added DeploymentInfo setting and Right’s use of newContainer(), so no altered or unchanged behavior is lost.
86;spring-boot;3444ebbc05b99a164474c14d6a6784f749514428;org.springframework.boot.context.web.SpringBootServletInitializer;createRootApplicationContext(ServletContext);[99];[121, 123];Modified a class's instance declaration, instead of using new Class(), called a method that does this.;Inserted a conditional (if) for an attribute that has not been changed from the left, checking if an attribute of the class is true or false.;No;False;"Left refactors how the SpringApplicationBuilder is created (uses a factory method instead of new), which is behavior-preserving by default and only enables customization. Right makes ErrorPageFilter registration conditional on registerErrorPageFilter. These changes affect different concerns and state; they do not interfere and the merged code preserves both behaviors."
87;spring-boot;074771ec125dd407af0282b92960e9e9e3377e84;org.springframework.boot.context.web.SpringBootServletInitializer;createRootApplicationContext(ServletContext);[87];[88];extracts the instantiation of the object to another method;Change an object's attribute using a set method;No;False;"LEFT refactors the creation of SpringApplicationBuilder by extracting it into a helper method (no behavior change by itself). RIGHT changes an object's attribute via a setter (e.g., updating a property on the builder or servletContext). These changes affect different concerns and can coexist: the builder can be created via the new method and the attribute can still be set afterward. No state value computed by B, L, or R is altered incorrectly by the merge; thus no semantic conflict."
88;spring-boot;fdd3f12ee0f92ac18844c08bf71df39feebb6673;org.springframework.boot.autoconfigure.logging.AutoConfigurationReportLoggingInitializer;logAutoConfigurationReport(boolean);[114];[110];Change the string sent as a parameter to the logger.debug method;Change the string sent as a parameter to the logger.info method;Yes;False;"Left changes the debug log message; Right changes the info log message shown only on crash when debug is disabled. They affect different log calls on different conditions and can coexist. The merged behavior preserves both changes without altering base behavior elsewhere."
89;spring-boot;2d4e68a9777601bfb8309c94d8b74bc21be80ad1;org.springframework.boot.context.embedded.tomcat.TomcatEmbeddedServletContainerFactory;customizeConnector(Connector);[240, 241, 242, 243, 244, 246, 247, 248, 249];[228];Added an if condition that has an asset in its body. One method call to configureSsl and two set method calls to connector;Added a wildcard to the generic of the AbstractProtocol class which is used as a casting;No;False;"LEFT adds SSL configuration in customizeConnector: asserts protocol handler is AbstractHttp11JsseProtocol when SSL is enabled, calls configureSsl, and sets scheme=https and secure=true. RIGHT only changes a cast to AbstractProtocol<?> when setting the connector address, which is a type-safety (generics) refinement with no runtime effect. The changes touch different concerns and lines, and their merge preserves both behaviors; no state element is computed differently due to the integration."
90;storm;ad2be678831b3b060229fd936e3908110162b7ac;org.apache.storm.kafka.spout.KafkaSpout;open(Map, TopologyContext, SpoutOutputCollector);[];[118, 102];Left removes the assignment value to field maxRetries, which was also removed by Left.;Right assigns a value for field refreshSubscriptionTimer, which was also added by Right.;No;False;Left removes the maxRetries field and its assignment (not present in this method), while Right adds initialization of refreshSubscriptionTimer in open(). These changes affect different state elements and do not alter or interfere with each other’s behavior. The merged result preserves Left’s removal of maxRetries and Right’s addition of refreshSubscriptionTimer without changing the behavior of unchanged parts of the base.
91;storm;ad2be678831b3b060229fd936e3908110162b7ac;org.apache.storm.kafka.spout.KafkaSpoutConfig;KafkaSpoutConfig(Builder<K,V>);[];[435, 436, 437, 438, 439, 440, 441, 430, 431];Left removes the assignment for field maxRetries, and also its declaration.;Right removes four fields and adds seven fields with their assignment.;No;False;Left removes the maxRetries field and its assignment from KafkaSpoutConfig(Builder), while Right removes four other fields and adds seven new fields with corresponding assignments. The Left change targets only the obsolete maxRetries state, and the Right change expands configuration with additional fields. These modifications affect different state elements and can coexist in the merged constructor without altering each other's intended behavior or the base behavior.
92;storm;ad2be678831b3b060229fd936e3908110162b7ac;org.apache.storm.kafka.spout.KafkaSpoutConfig;toString();[];[515, 516, 521, 522];"Left removes the field and reference for maxRetries of the returning string from the method toString();";Right performs a refactoring involving the references for key and value variables. It updates how the variable values are accessed (now using get methods instead of directly accessing the values). Right also removes references to the field: kafkaSpoutStreams, tuplesBuilder, topics, and topicWildcardPattern. Finally, it adds reference for subscription and translator.;Yes;False;"Left only removes the maxRetries detail from the toString output. Right refactors toString to use getters for key/value and replaces/updates listed fields (removing kafkaSpoutStreams/tuplesBuilder/topics/topicWildcardPattern and adding subscription/translator). These changes are orthogonal; the merged toString per Right’s refactor won’t include maxRetries anyway, so both intents are preserved and no behavior outside of string formatting is impacted."
93;storm;bd1f5c54752f67b484a83c26667331234234d3a3;org.apache.storm.kafka.spout.KafkaSpout;emitTupleIfNotEmitted(ConsumerRecord<K,V>);[305, 306, 307, 312];[316, 319];"Left performs a refactoring extracting a variable of an IF statement; it also changes another IF condition.";Right updates the method signature changing its return type for boolean and adds return statements.;No;False;Left refactors the emission guard logic (extracting a variable and tweaking an if condition), while Right changes the method to return a boolean and adds return statements reflecting whether an emit occurred. Right’s change reports the outcome without altering the decision to emit or state updates. The combined result preserves Left’s modified emission behavior and Right’s new return semantics, so there is no semantic interference.
94;swagger-core;e7fea7c4889dbdd6a4e0b2d059c8aa0f126ab1c2;io.swagger.jaxrs2.OperationParser;getSchemaFromAnnotation(io.swagger.oas.annotations.media.Schema);[240, 241, 234, 235, 236, 237, 238, 239];[244, 187, 188];Left adds two IF statements, which may set some fields on object schemaObject.;Right renames three methods _enum() to allowableValues(), and _default() to defaultValue;No;False;Left adds new conditional assignments to schemaObject (additional fields), while Right only renames annotation accessors (_enum -> allowableValues, _default -> defaultValue). These changes affect different concerns/lines and are compatible: the merged code can both set the new fields and use the renamed methods. No state element gets a different value due to the integration, so no semantic conflict.
95;titan;387c16ea05ef9fa312f37139228d2bbf61455ff4;com.thinkaurelius.titan.graphdb.database.serialize.SerializerInitialization;initialize(Serializer);[52, 53, 54, 55, 57];[31];Left adds and removes calls for method registerClass of serialize object, that registers new classes in the registrations hashmap.;Right changes one call for method registerClass by adding a new parameter (instead of only two), and this new parameter will be added into headers hashmap.;No;False;"Left adds/removes several registerClass calls (new classes/ids), while Right modifies a single registerClass call by adding a header parameter without changing its class or id. They touch different registrations/state (Left: registrations map entries; Right: adds a header for one existing entry). No overlapping class/id is modified by both, so merged behavior preserves both changes and base behavior."
96;titan;04edd7f0e7eab2e8255a497922e34dc707d84c19;com.thinkaurelius.titan.graphdb.transaction.StandardTitanTx;StandardTitanTx(StandardTitanGraph, TransactionConfiguration, BackendTransaction);[182, 183];[197, 198, 199];Left created three private final type attributes and assigned two of them with a constructor within the method.;Right added a conditional and used other statements: config.getMetricsPrefix() and MetricManager.INSTANCE.getCounter(config.getMetricsPrefix());No;False;Left adds three final Retriever fields (instantiating two in the constructor) to reuse VertexConstructor instances, which is a refactoring that does not change behavior. Right adds metrics counter increments guarded by a null-check on config.getMetricsPrefix() in the constructor (and likely commit/rollback). These changes touch disjoint concerns (vertex retriever initialization vs. metrics) and do not alter shared state or computed values, so their integration preserves both behaviors.
97;voldemort;b30fdfebe30c9b6e37b9fbc3fec0ff74cd19f997;voldemort.VoldemortClientShell;VoldemortClientShell(ClientConfig, String, BufferedReader, PrintStream, PrintStream);[123];[128, 127];Left changed the parameters for the constructor of the adminClient object, inserting the reference passed by parameter instead of a new object.;Right created a local variable called 'cluster' that access the 'adminClient' attribute and assigned a 'RoutingStrategyFactory' object to routingStrategy, passing the created variable.;Yes;False;"Left changes the AdminClient construction to reuse the passed ClientConfig instead of creating a new one. Right adds initialization of routingStrategy by retrieving the cluster from adminClient and using RoutingStrategyFactory. These changes are complementary: Right relies only on adminClient being initialized, which Left still ensures, and using the same ClientConfig does not invalidate Right’s logic. No state is computed inconsistently compared to L or R; behavior composes without interference."
98;voldemort;4cc1c145819030c8e2baffe4c92383de14b8d880;voldemort.server.VoldemortConfig;VoldemortConfig(Props);[359];[448, 455];Inserted a change to the readOnlyLoginIntervalMs attribute using the the object 'props' passed by parameter and the method getLong.;Inserted changes to the attributes nioConnectorKeepAlive and nioAdminConnectorKeepAlive, using the props object passed by parameter and the getBoolean methods and two different strings.;No;False;"LEFT adds reading fetcher.login.interval.ms into readOnlyLoginIntervalMs; RIGHT adds reading nio.connector.keepalive and nio.admin.connector.keepalive booleans. These changes affect different fields and subsystems (read-only fetcher vs NIO keepalive) and do not overlap or alter each other’s behavior. The merged constructor includes all three property reads, preserving both behaviors."
99;webbit;74d2d2b87704d003acacb34e4ca8fb5f897b938f;org.webbitserver.netty.WebSocketClient;adjustPipelineToWebSocket(ChannelHandlerContext, MessageEvent, ChannelHandler, ChannelHandler);[260];[262];Left sets the version of webSockectConnection object calling the method setHybiWebSocketVersion.;"Right changes the order of parameters used to create the local variable webSocketChannelHandler; so it's a refactoring.";No;False;Left adds a configuration call to set the HyBi WebSocket version on the newly created NettyWebSocketConnection. Right refactors the constructor argument order when creating WebSocketConnectionHandler to match a signature change, without changing behavior. They modify different lines and independent concerns: one configures the connection, the other adjusts handler instantiation. Merging both preserves both behaviors and does not alter any state element’s computed value relative to Left or Right individually.
